**Key Findings:**

1. **Problem Structure:**
   - We need to count the number of permutations of \( N + M \) sushi pieces where \( N \) are nigiri with tastiness values \( A_i \leq 100 \) and \( M \) are sashimi with tastiness values \( B_i \geq 101 \).
   - The "unevenness score" \( S(P) \) is the sum of absolute differences between consecutive elements in the permutation, and we need \( S(P) \leq L \).

2. **Constraints Analysis:**
   - \( N \) can be up to 50 and \( M \) up to 5, making the total number of pieces \( n \) up to 55.
   - Directly computing all permutations is infeasible due to factorial time complexity.
   - However, \( M \) is small (up to 5), which suggests that we can leverage this to optimize our solution.

3. **Dynamic Programming Approach:**
   - Utilize dynamic programming (DP) to build permutations incrementally, keeping track of:
     - Which sashimi pieces have been placed (using a bitmask since \( M \) is small).
     - The last placed piece to calculate the next difference.
     - The accumulated unevenness score.
   - Since \( L \) can be up to \( 10^9 \), we need to optimize how we track and update the DP states to handle large sums efficiently.

4. **State Representation:**
   - The DP state can be represented as \( (mask, last, sum) \), where:
     - \( mask \) is a bitmask representing which sashimi pieces have been placed.
     - \( last \) is the last placed piece's tastiness value.
     - \( sum \) is the current accumulated unevenness.
   - Due to the large possible range of \( sum \), we need to use techniques like pruning or memoization to keep the state space manageable.

5. **Optimization Strategies:**
   - Precompute all possible differences between pieces to speed up the DP transitions.
   - Since nigiri pieces have smaller and bounded values (\( \leq 100 \)), handle transitions between them more efficiently.
   - For sashimi pieces, handle their placement carefully to account for their larger differences and ensure the cumulative sum does not exceed \( L \).

6. **Modular Arithmetic:**
   - Since the number of valid permutations can be very large, all calculations should be done modulo \( 1{,}000{,}000{,}007 \).

**Python Code:**

```python
import sys
import threading
from collections import defaultdict
import math

MOD = 10**9 + 7

def main():
    import sys
    import sys
    sys.setrecursionlimit(1 << 25)
    T = int(sys.stdin.readline())
    for test_case in range(1, T+1):
        N, M, L = map(int, sys.stdin.readline().split())
        A = list(map(int, sys.stdin.readline().split()))
        B = list(map(int, sys.stdin.readline().split()))
        
        # Combine all elements with their types
        elements = []
        for a in A:
            elements.append(('A', a))
        for b in B:
            elements.append(('B', b))
        
        # Assign unique indices
        indices = list(range(N+M))
        
        # Precompute differences
        diffs = [[0]*(N+M) for _ in range(N+M)]
        for i in range(N+M):
            for j in range(N+M):
                diffs[i][j] = abs(elements[i][1] - elements[j][1])
        
        from functools import lru_cache
        
        @lru_cache(maxsize=None)
        def dp(mask, last, s):
            if s > L:
                return 0
            if mask == (1<<(N+M)) -1:
                return 1
            total = 0
            for next in range(N+M):
                if not (mask & (1<<next)):
                    if last == -1:
                        new_sum = s
                    else:
                        new_sum = s + diffs[last][next]
                    if new_sum > L:
                        continue
                    total += dp(mask | (1<<next), next, new_sum)
                    if total >= MOD:
                        total -= MOD
            return total % MOD
        
        result = dp(0, -1, 0)
        print(f"Case #{test_case}: {result}")

threading.Thread(target=main,).start()
```