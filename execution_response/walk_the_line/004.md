**Key Findings:**

To solve the bridge-crossing problem efficiently, we can employ a greedy algorithm inspired by the classic bridge-crossing puzzle. Here's the approach:

1. **Sort the Travelers:** Begin by sorting the travelers' crossing times in ascending order. This allows us to easily identify the fastest and slowest travelers.

2. **Greedy Strategy:** 
   - **Option 1:** Send the two fastest travelers across first. One of them returns with the flashlight. Then, send the two slowest travelers across, and the second fastest returns with the flashlight.
   - **Option 2:** Send the fastest traveler with the slowest traveler across. The fastest traveler returns with the flashlight. Then, send the fastest traveler with the second slowest traveler across, and the fastest traveler returns again.

   At each step, choose the option that results in the minimal total time.

3. **Iterate Until All Travelers Have Crossed:** Continue applying the above strategy until all travelers have crossed the bridge. Handle scenarios where there are 1, 2, or 3 travelers remaining separately.

4. **Compare with Allowed Time:** After calculating the minimal total crossing time, compare it with the allowed time \( K \). If the total time is within \( K \), output "YES"; otherwise, output "NO".

This approach ensures that the total crossing time is minimized by optimally choosing which travelers should cross together and who should return with the flashlight.

```python
def bridge_crossing():
    import sys
    import sys
    import sys
    T = int(sys.stdin.readline())
    for test_case in range(1, T+1):
        line = ''
        while line.strip() == '':
            line = sys.stdin.readline()
        N_K = line.strip().split()
        N = int(N_K[0])
        K = int(N_K[1])
        S = []
        count = 0
        while count < N:
            s_line = sys.stdin.readline()
            if s_line.strip() != '':
                S.append(int(s_line.strip()))
                count +=1
        S.sort()
        total_time =0
        n = N
        while n >3:
            option1 = 2*S[1] + S[0] + S[n-1]
            option2 = 2*S[0] + S[n-2] + S[n-1]
            total_time += min(option1, option2)
            n -=2
        if n ==3:
            total_time += S[0] + S[1] + S[2]
        elif n ==2:
            total_time += S[1]
        elif n ==1:
            total_time += S[0]
        if total_time <= K:
            result = "YES"
        else:
            result = "NO"
        print(f"Case #{test_case}: {result}")

if __name__ == "__main__":
    bridge_crossing()
```

```python
def bridge_crossing():
    import sys
    import sys
    import sys
    T = int(sys.stdin.readline())
    for test_case in range(1, T+1):
        line = ''
        while line.strip() == '':
            line = sys.stdin.readline()
        N_K = line.strip().split()
        N = int(N_K[0])
        K = int(N_K[1])
        S = []
        count = 0
        while count < N:
            s_line = sys.stdin.readline()
            if s_line.strip() != '':
                S.append(int(s_line.strip()))
                count +=1
        S.sort()
        total_time =0
        n = N
        while n >3:
            option1 = 2*S[1] + S[0] + S[n-1]
            option2 = 2*S[0] + S[n-2] + S[n-1]
            total_time += min(option1, option2)
            n -=2
        if n ==3:
            total_time += S[0] + S[1] + S[2]
        elif n ==2:
            total_time += S[1]
        elif n ==1:
            total_time += S[0]
        if total_time <= K:
            result = "YES"
        else:
            result = "NO"
        print(f"Case #{test_case}: {result}")

if __name__ == "__main__":
    bridge_crossing()
```