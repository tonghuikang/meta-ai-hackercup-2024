To solve this problem, we need to calculate the expected number of dollar bills required to collect all \( N \) coin denominations, using an optimal strategy that decides how many bills to insert each time. The key is to model the expected bills needed to collect a new coin as a function of the remaining coins to collect (\( S \)) and the number of bills inserted (\( D \)).

Here are the key steps:

1. **Compute Optimal \( D \) for Each \( S \):**
   - For each \( D \) (number of bills you can insert), calculate the probability of getting a new coin (\( p\_new \)) using \( p\_new = \min((D - 1) \cdot P,\ 100) / 100 \).
   - Compute the threshold \( s = S / N \) where it becomes optimal to switch from one \( D \) to another using the formula \( s = \frac{p\_new}{D - 1 + p\_new} \).
   - Collect the pairs of \( (s, D) \) and sort them to identify the ranges of \( S \) where each \( D \) is optimal.

2. **Calculate Expected Bills Using Integration:**
   - Since we can't sum over each \( S \) individually (due to large \( N \)), we use integrals to calculate the expected bills over ranges where \( D \) remains constant.
   - For ranges where \( p\_new = 0 \) or \( p\_new = 1 \), the integrals simplify, and we can compute the expected bills directly.

3. **Sum Total Expected Bills:**
   - For each range determined in step 1, calculate the total expected bills using the appropriate integral.
   - Sum the expected bills from all ranges to get the total expected number of bills required.

Now, here is the Python code implementing the above logic:

```python
import sys
import math

def readints():
    return list(map(int, sys.stdin.readline().split()))

T = int(sys.stdin.readline())
for case_num in range(1, T + 1):
    N_str, P_str = sys.stdin.readline().split()
    N = int(N_str)
    P = float(P_str)

    N_float = float(N)
    # Handle P == 0 separately
    if P == 0.0:
        # Total expected bills is N * H_N
        # Since N can be large, use ln(N) approximation
        total_expected_bills = N_float * (math.log(N_float) + 0.5772156649)
    else:
        # Build a list of (s, D) pairs
        D_list = []
        D = 1
        s = 1.0  # For D=1, s=1
        D_list.append((s, D))
        P_fraction = P / 100.0
        D_max = 1000  # We'll limit D to prevent infinite loops (since P can be small)
        for D in range(2, D_max + 1):
            p_new = min((D - 1) * P_fraction, 1.0)
            # If p_new == 0 and D > 1, no benefit in further D
            if p_new == 0.0:
                break
            if p_new < 1.0:
                s = p_new / (D - 1 + p_new)
            else:
                s = 1.0 / D
            D_list.append((s, D))
            if p_new == 1.0:
                # For p_new == 1, further increases in D only decrease s, which may be unnecessary
                break
        # Sort D_list in decreasing s
        D_list.sort(reverse=True)
        # Build ranges of s where D is optimal
        total_expected_bills = 0.0
        s_prev = 1.0
        # Append (0.0, None) to handle the last range
        D_list.append((0.0, None))
        for i in range(len(D_list) -1 ):
            s_curr, D_curr = D_list[i]
            s_next, D_next = D_list[i +1]
            # For S/N in [s_next, s_curr), D_curr is optimal
            S_prev = s_curr * N_float
            S_next = s_next * N_float
            if D_curr == 1:
                # For D=1, total_expected_bills = N * [ ln(S_prev / S_next ) ]
                total_expected_bills += N_float * (math.log(S_prev) - math.log(S_next))
            elif D_curr is not None:
                p_new = min((D_curr -1) * P_fraction, 1.0)
                if p_new == 1.0:
                    # Total expected bills = D * (S_prev - S_next )
                    expected_bills = D_curr * (S_prev - S_next)
                    total_expected_bills += expected_bills
                else:
                    a = p_new
                    b = 1.0 - p_new
                    coeff = D_curr * N_float / b
                    x1 = (S_prev) / N_float
                    x2 = (S_next) / N_float
                    term1 = math.log(a + b * x1)
                    term2 = math.log(a + b * x2)
                    total_expected_bills += coeff * (term1 - term2)
        # Adjust total_expected_bills if negative due to numerical errors
        total_expected_bills = max(total_expected_bills, 0.0)

    # Format the output with sufficient precision
    print(f"Case #{case_num}: {total_expected_bills}")
```

This code reads each test case, computes the optimal number of bills to insert at each step, and then calculates the expected total number of bills required using the methods described above. By carefully handling the calculations and integrating over the ranges of \( S \), we can efficiently compute the expected bills even for very large \( N \).