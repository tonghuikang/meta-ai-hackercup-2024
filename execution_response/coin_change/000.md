**Key Findings:**

1. **Understanding the Problem:**
   - We need to calculate the expected number of dollar bills required to collect all \(N\) distinct coin denominations using a machine that provides coins based on the number of dollar bills inserted (\(D\)) and a probability parameter \(P\).
   - For each exchange, the probability of receiving a new denomination is influenced by how much you spend (\(D\)) and the parameter \(P\).

2. **Special Cases:**
   - **When \(P = 0\):** This reduces to the classic coupon collector problem where the expected number of exchanges is \(N \times H_N\) (where \(H_N\) is the \(N\)-th harmonic number).
   - **When \(P = 100\):** It's optimal to spend \(D = 1\) until it's more efficient to spend higher \(D\) to guarantee receiving a new denomination.

3. **General Approach for \(0 < P < 100\):**
   - For each denomination count \(k\) (from 0 to \(N-1\)), determine the optimal number of dollars \(D\) to spend to minimize the expected cost to obtain the next unique coin.
   - Calculate the probability of getting a new coin based on the chosen \(D\) and \(P\).
   - Use mathematical optimization to find the best \(D\) for each \(k\), considering crossover points where different \(D\) values become optimal.
   - Sum the expected costs across all \(k\) to obtain the total expected number of dollars required.

4. **Mathematical Computations:**
   - When \(N\) is extremely large (up to \(10^{15}\)), directly summing over all \(k\) is infeasible. Thus, we approximate the sum using integrals, treating \(k\) as a continuous variable.
   - The harmonic number \(H_N\) is approximated using the natural logarithm and Euler-Mascheroni constant for large \(N\) to maintain precision.

5. **Implementation Considerations:**
   - Efficiently handle the crossover points between different \(D\) values to partition the integration range.
   - Use floating-point precision carefully to ensure the relative error remains within the acceptable range.
   - Optimize for performance given the constraints on \(T\) and \(N\).

Below is the Python code implementing the above approach:

```python
import sys
import math
from itertools import combinations
from math import log
from bisect import bisect

# Euler-Mascheroni constant
gamma_const = 0.57721566490153286060651209008240243104215933593992

def harmonic_approx(N):
    if N == 0:
        return 0.0
    if N < 1e6:
        # Compute exact harmonic number
        H = 0.0
        for k in range(1, N+1):
            H += 1.0 / k
        return H
    else:
        # Use approximation
        # H_N â‰ˆ ln(N) + gamma + 1/(2N) - 1/(12 N^2) + 1/(120 N^4)
        inv_N = 1.0 / N
        inv_N2 = inv_N * inv_N
        inv_N4 = inv_N2 * inv_N2
        return math.log(N) + gamma_const + 0.5 * inv_N - (1.0 / 12.0) * inv_N2 + (1.0 / 120.0) * inv_N4

def compute_expected_bills(N, P):
    if P == 0:
        # Classic coupon collector
        H_N = harmonic_approx(N)
        return H_N * N
    else:
        # Enumerate possible D
        D_list = []
        D_max = 1
        if P >0:
            D_max = math.ceil(100 / P) +1
        D_max = max(D_max, 1)
        for D in range(1, D_max+1):
            s = (D-1)*P
            if s >100:
                s = 100
            D_list.append( (D, s) )
        # Now find all crossover points
        crossover_p = set()
        for (D1, s1), (D2, s2) in combinations(D_list, 2):
            numerator = D2 * s1 / 100.0 - D1 * s2 / 100.0
            denominator = D1 * (1 - s2 /100.0) - D2 * (1 - s1 /100.0)
            if denominator ==0:
                continue
            p = numerator / denominator
            if 0 <= p <=1:
                crossover_p.add(p)
        # Add 0 and1
        crossover_p.add(0.0)
        crossover_p.add(1.0)
        # Sort the p's
        sorted_p = sorted(crossover_p)
        # Now find intervals between sorted_p[i] to sorted_p[i+1]
        # For each interval, choose D with minimum f_D(p_mid)
        # Precompute all D's f_D(p_mid)
        intervals = []
        for i in range(len(sorted_p)-1):
            p_left = sorted_p[i]
            p_right = sorted_p[i+1]
            p_mid = (p_left + p_right) /2.0
            min_f = float('inf')
            best_D = None
            for (D, s) in D_list:
                denominator = s /100.0 + (1 - s /100.0 ) * p_mid
                if denominator ==0:
                    continue
                f = D / denominator
                if f < min_f:
                    min_f = f
                    best_D = D
            if best_D is not None:
                intervals.append( (p_left, p_right, best_D) )
        # Now compute the integral over each interval
        total_integral =0.0
        for (p_l, p_r, D) in intervals:
            # Find s for this D
            for (d,s) in D_list:
                if d == D:
                    s_D = s
                    break
            denom_coeff = 1 - s_D /100.0
            if denom_coeff ==0:
                # f_D(p)=D / (s/100), constant
                integral = D / (s_D /100.0 ) * (p_r - p_l)
            else:
                term_r = s_D /100.0 + denom_coeff * p_r
                term_l = s_D /100.0 + denom_coeff * p_l
                if term_r <=0 or term_l <=0:
                    # log undefined, skip
                    continue
                integral = D / denom_coeff * (math.log(term_r) - math.log(term_l))
            total_integral += integral
        # Now total expected bills is N * total_integral
        # But p ranges from 0 to1, and K from0 to N-1, so scaling is correct
        expected_bills = total_integral * N
        return expected_bills

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    T = int(data[0])
    idx =1
    for tc in range(1, T+1):
        N_str, P_str = data[idx], data[idx+1]
        N = int(N_str)
        P = int(P_str)
        idx +=2
        expected = compute_expected_bills(N, P)
        # Format the output: use scientific notation if large
        if expected >=1e10:
            output = "{:.10E}".format(expected)
        else:
            output = "{:.10f}".format(expected).rstrip('0').rstrip('.')
        print(f"Case #{tc}: {output}")

if __name__ == "__main__":
    main()
```