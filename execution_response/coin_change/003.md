**Key Findings:**

To solve the problem of determining the expected number of dollar bills required to collect all `N` distinct coin denominations optimally, we analyze the behavior based on the probability `P` and the number of denominations `N`.

1. **Probability `P` and Dollar Bills `D`:**
   - The probability of receiving a new coin when inserting `D` bills is `Q(D) = min((D-1)*P / 100, 1)`.
   - For each state `m` (number of missing coins), we aim to choose the optimal `D` that minimizes the expected bills for collecting the next unique coin.

2. **Strategy Based on `N`:**
   - **Small `N` (â‰¤ 10^5):** For smaller values of `N`, calculate the expected number of bills per coin by iterating through each missing coin and selecting the optimal `D` for each state.
   - **Large `N` (> 10^5):** For larger `N`, use an integral approximation to compute the expected number of bills efficiently, leveraging the continuous nature of the problem when `N` is large.

3. **Harmonic Number for `P = 0`:**
   - When `P = 0`, the problem reduces to calculating the harmonic number `H_N = 1 + 1/2 + 1/3 + ... + 1/N`. For large `N`, use an asymptotic expansion to approximate `H_N` accurately.

4. **Integration Approach for Large `N` and `P > 0`:**
   - Determine all potential breakpoints `x` where the optimal `D` changes.
   - Sort these breakpoints and partition the interval [0,1] accordingly.
   - For each partition, compute the integral of the expected bills and sum them to get the total expected bills.

5. **Edge Cases:**
   - Handle cases where `P = 0` and `P = 100` carefully to ensure accurate computations.
   - Ensure that all computations maintain a high precision to meet the required relative error constraint.

The solution efficiently handles both small and large values of `N`, ensuring optimal performance and accuracy. Below is the Python implementation adhering to these findings.

```python
import math
import sys

def harmonic_sum(N):
    if N == 0:
        return 0.0
    if N < 1000000:
        h = 0.0
        for m in range(1, N+1):
            h += 1.0 / m
        return h
    else:
        gamma = 0.57721566490153286060651209008240243104215933593992
        H = math.log(N) + gamma + 1.0/(2.0*N) - 1.0/(12.0*N**2) + 1.0/(120.0*N**4)
        return H

def compute_expected_bills(N, P):
    if P ==0:
        H = harmonic_sum(N)
        return N * H
    elif N <=100000:
        D_max = math.ceil(100.0 / P ) +1
        D_max = max(D_max,1)
        Ds = []
        for D in range(1, D_max+1):
            Q = ((D-1)*P)/100.0
            if Q >1.0:
                Q =1.0
            Ds.append( (D, Q) )
        total =0.0
        for m in range(1, N+1):
            x = m / N
            min_E = float('inf')
            for (D, Q) in Ds:
                denominator = Q + (1 - Q)*x
                if denominator <=0.0:
                    continue
                E = D / denominator
                if E < min_E:
                    min_E=E
            total += min_E
        return total
    else:
        D_max = math.ceil(100.0 / P ) +1
        D_max = max(D_max,1)
        Ds = []
        for D in range(1, D_max+1):
            Q = ((D-1)*P)/100.0
            if Q >1.0:
                Q =1.0
            Ds.append( (D, Q) )
        breakpoints = set()
        for i in range(len(Ds)):
            D1, Q1 = Ds[i]
            for j in range(i+1, len(Ds)):
                D2, Q2 = Ds[j]
                numerator = D2*Q1 - D1*Q2
                denominator = D1*(1 - Q2) - D2*(1 - Q1)
                if denominator ==0:
                    continue
                x = numerator / denominator
                if 0.0 <x <1.0:
                    breakpoints.add(x)
        sorted_x = sorted(breakpoints)
        sorted_x = [0.0] + sorted_x + [1.0]
        regions = []
        for i in range(len(sorted_x)-1):
            a = sorted_x[i]
            b = sorted_x[i+1]
            x_mid = (a + b)/2.0
            min_E = float('inf')
            best_D = None
            for (D, Q) in Ds:
                denominator = Q + (1 - Q)*x_mid
                if denominator <=0.0:
                    continue
                E = D / denominator
                if E < min_E:
                    min_E=E
                    best_D=D
            regions.append( (a, b, best_D) )
        total_integral =0.0
        D_Q_map = dict(Ds)
        for (a, b, D) in regions:
            Q = D_Q_map[D]
            if Q <1.0:
                if (1 - Q) ==0.0:
                    # Avoid division by zero, but Q<1 implies (1-Q)!=0
                    integral = D * (b -a)
                else:
                    term_a = Q + (1 - Q)*a
                    term_b = Q + (1 - Q)*b
                    if term_a <=0 or term_b <=0:
                        # ln undefined, skip
                        continue
                    integral = D / (1 - Q) * (math.log(term_b) - math.log(term_a))
            else:
                integral = D * (b -a)
            total_integral += integral
        return N * total_integral

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    T=int(data[0])
    index=1
    for tc in range(1, T+1):
        N=int(data[index])
        P=int(data[index+1])
        index +=2
        expected_bills=compute_expected_bills(N,P)
        # Format the output with sufficient precision
        if expected_bills <1e10:
            print(f"Case #{tc}: {expected_bills}")
        else:
            # Use scientific notation for large numbers
            print(f"Case #{tc}: {expected_bills:.12E}")
            
if __name__ == "__main__":
    main()
```

```python
import math
import sys

def harmonic_sum(N):
    if N == 0:
        return 0.0
    if N < 1000000:
        h = 0.0
        for m in range(1, N+1):
            h += 1.0 / m
        return h
    else:
        gamma = 0.57721566490153286060651209008240243104215933593992
        H = math.log(N) + gamma + 1.0/(2.0*N) - 1.0/(12.0*N**2) + 1.0/(120.0*N**4)
        return H

def compute_expected_bills(N, P):
    if P ==0:
        H = harmonic_sum(N)
        return N * H
    elif N <=100000:
        D_max = math.ceil(100.0 / P ) +1
        D_max = max(D_max,1)
        Ds = []
        for D in range(1, D_max+1):
            Q = ((D-1)*P)/100.0
            if Q >1.0:
                Q =1.0
            Ds.append( (D, Q) )
        total =0.0
        for m in range(1, N+1):
            x = m / N
            min_E = float('inf')
            for (D, Q) in Ds:
                denominator = Q + (1 - Q)*x
                if denominator <=0.0:
                    continue
                E = D / denominator
                if E < min_E:
                    min_E=E
            total += min_E
        return total
    else:
        D_max = math.ceil(100.0 / P ) +1
        D_max = max(D_max,1)
        Ds = []
        for D in range(1, D_max+1):
            Q = ((D-1)*P)/100.0
            if Q >1.0:
                Q =1.0
            Ds.append( (D, Q) )
        breakpoints = set()
        for i in range(len(Ds)):
            D1, Q1 = Ds[i]
            for j in range(i+1, len(Ds)):
                D2, Q2 = Ds[j]
                numerator = D2*Q1 - D1*Q2
                denominator = D1*(1 - Q2) - D2*(1 - Q1)
                if denominator ==0:
                    continue
                x = numerator / denominator
                if 0.0 <x <1.0:
                    breakpoints.add(x)
        sorted_x = sorted(breakpoints)
        sorted_x = [0.0] + sorted_x + [1.0]
        regions = []
        for i in range(len(sorted_x)-1):
            a = sorted_x[i]
            b = sorted_x[i+1]
            x_mid = (a + b)/2.0
            min_E = float('inf')
            best_D = None
            for (D, Q) in Ds:
                denominator = Q + (1 - Q)*x_mid
                if denominator <=0.0:
                    continue
                E = D / denominator
                if E < min_E:
                    min_E=E
                    best_D=D
            regions.append( (a, b, best_D) )
        total_integral =0.0
        D_Q_map = dict(Ds)
        for (a, b, D) in regions:
            Q = D_Q_map[D]
            if Q <1.0:
                if (1 - Q) ==0.0:
                    # Avoid division by zero, but Q<1 implies (1-Q)!=0
                    integral = D * (b -a)
                else:
                    term_a = Q + (1 - Q)*a
                    term_b = Q + (1 - Q)*b
                    if term_a <=0 or term_b <=0:
                        # ln undefined, skip
                        continue
                    integral = D / (1 - Q) * (math.log(term_b) - math.log(term_a))
            else:
                integral = D * (b -a)
            total_integral += integral
        return N * total_integral

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    T=int(data[0])
    index=1
    for tc in range(1, T+1):
        N=int(data[index])
        P=int(data[index+1])
        index +=2
        expected_bills=compute_expected_bills(N,P)
        # Format the output with sufficient precision
        if expected_bills <1e10:
            print(f"Case #{tc}: {expected_bills}")
        else:
            # Use scientific notation for large numbers
            print(f"Case #{tc}: {expected_bills:.12E}")
            
if __name__ == "__main__":
    main()
```