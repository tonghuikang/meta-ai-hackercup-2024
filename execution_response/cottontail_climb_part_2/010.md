**Key Findings:**

1. **Mountain Number Characteristics:**
   - A mountain number has an odd number of digits (\(2k + 1\)), with no zeros.
   - The first \(k+1\) digits are monotonically non-decreasing.
   - The last \(k+1\) digits are monotonically non-increasing.
   - The middle digit must be unique (appears exactly once in the number).

2. **Generation Strategy:**
   - Iterate over all possible lengths (\(1, 3, 5, \ldots, 19\) digits).
   - For each length, generate all possible non-decreasing sequences for the first \(k+1\) digits.
   - Select a unique middle digit that doesn't appear in the first \(k\) or the last \(k\) digits.
   - Generate the last \(k\) digits as a non-increasing sequence based on the middle digit.

3. **Efficiency Considerations:**
   - Precompute all mountain numbers up to \(10^{18}\) since their total count is manageable.
   - Sort the mountain numbers to enable efficient range queries using binary search.
   - For each test case, use binary search to identify mountain numbers within \([A, B]\) and count those divisible by \(M\).

4. **Divisibility Check:**
   - Since mountain numbers are precomputed and sorted, iterate through the relevant subset and count those divisible by \(M\).
   - This approach is feasible given the constraints (\(T \leq 95\) and reasonable mountain number counts).

5. **Edge Cases:**
   - Handle single-digit mountain numbers (\(1-9\)).
   - Ensure that the middle digit is unique, especially for smaller lengths where duplication is more likely.

**Python Code:**

```python
import sys
import bisect

def generate_mountain_numbers():
    mountains = []

    def backtrack(k, pos, current, last, unique_mid, digits_set, mid_digit, n):
        if pos == n:
            num = int(''.join(map(str, current)))
            mountains.append(num)
            return
        if pos == k:
            # Middle digit, must be unique
            for d in range(1, 10):
                if d not in digits_set:
                    current.append(d)
                    backtrack(k, pos + 1, current, d, True, digits_set | {d}, d, n)
                    current.pop()
        elif pos < k:
            for d in range(last, 10):
                if d not in digits_set:
                    current.append(d)
                    backtrack(k, pos + 1, current, d, unique_mid, digits_set | {d}, mid_digit, n)
                    current.pop()
        else:
            # After middle digit, non-increasing
            for d in range(current[k] if pos == k +1 else current[-1], 0, -1):
                if d not in digits_set:
                    current.append(d)
                    backtrack(k, pos + 1, current, d, unique_mid, digits_set | {d}, mid_digit, n)
                    current.pop()

    for n in range(1, 20, 2):
        k = n // 2
        backtrack(k, 0, [], 0, False, set(), 0, n)

    mountains.sort()
    return mountains

def main():
    mountains = generate_mountain_numbers()
    T = int(sys.stdin.readline())
    for case in range(1, T +1):
        A, B, M = map(int, sys.stdin.readline().split())
        # Find the range in mountains
        left = bisect.bisect_left(mountains, A)
        right = bisect.bisect_right(mountains, B)
        count = 0
        for num in mountains[left:right]:
            if num % M ==0:
                count +=1
        print(f"Case #{case}: {count}")

if __name__ == "__main__":
    main()
```