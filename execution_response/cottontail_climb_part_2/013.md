**Key Findings:**

1. **Mountain Number Structure:**
   - A mountain number has an odd number of digits, specifically \(2k + 1\) digits for some integer \(k \geq 0\).
   - All digits are non-zero.
   - The first \(k+1\) digits are monotonically non-decreasing.
   - The last \(k+1\) digits are monotonically non-increasing.
   - The middle digit is unique, meaning it appears only once in the entire number.

2. **Generating Mountain Numbers:**
   - For each possible length \(2k + 1\) (where \(k\) ranges from 0 to 9 to keep the number within \(10^{18}\)), generate all valid mountain numbers.
   - For each \(k\), iterate over possible middle digits \(m\) from 1 to 9.
   - Generate all possible non-decreasing sequences for the first \(k\) digits with digits ranging from 1 to \(m-1\).
   - Generate all possible non-increasing sequences for the last \(k\) digits with digits ranging from 1 to \(m-1\).
   - Combine these sequences with the middle digit \(m\) to form complete mountain numbers.
   - Ensure the middle digit does not repeat in any other position.

3. **Counting Divisible Mountain Numbers:**
   - Precompute and store all mountain numbers in a sorted list.
   - For each test case, use binary search to identify mountain numbers within the range \([A, B]\).
   - Iterate through the identified subset and count how many of these numbers are divisible by \(M\).

4. **Efficiency Considerations:**
   - The number of mountain numbers is manageable (likely around 100,000) since the constraints limit the length and digit options.
   - Precomputing mountain numbers and sorting them allows for efficient querying using binary search.
   - Handling multiple test cases becomes feasible within the given constraints.

**Python Code:**

```python
import sys
import itertools
import bisect

def generate_mountain_numbers():
    mountains = set()
    # Handle k=0 separately: single-digit numbers from 1 to 9
    for m in range(1, 10):
        mountains.add(m)
    # For k=1 to 9 (length=3 to 19)
    for k in range(1, 10):
        length = 2 * k +1
        for m in range(1, 10):
            if m ==1 and k >=1:
                # For m=1 and k>=1, first k digits from 1 to m-1=0, which is invalid
                continue
            # Generate all possible first k digits: non-decreasing, digits from 1 to m-1
            if m-1 <1 and k>=1:
                # No valid digits for first k digits
                continue
            if k ==0:
                first_parts = [()]
            else:
                # Non-decreasing sequences: combinations with replacement
                first_parts = itertools.combinations_with_replacement(range(1, m), k)
            # Similarly, generate all possible last k digits: non-increasing, digits from 1 to m-1
            if m-1 <1 and k>=1:
                # No valid digits for last k digits
                continue
            if k ==0:
                last_parts = [()]
            else:
                last_parts = itertools.combinations_with_replacement(range(1, m), k)
                # To make non-increasing, we need to sort each combination in reverse
                last_parts = [tuple(reversed(part)) for part in last_parts]
            # Combine first_parts and last_parts
            if k ==0:
                # Only the middle digit
                mountains.add(m)
            else:
                for first in first_parts:
                    # Ensure first is non-decreasing
                    # Already ensured by combinations_with_replacement
                    for last in last_parts:
                        # Ensure last is non-increasing
                        # Already ensured by reversed combinations
                        # Now, assemble the number
                        num_digits = list(first) + [m] + list(last)
                        # Now, check if middle digit m is unique
                        # Since first k digits are <m and last k digits are <=m-1 <m, m appears only once
                        # So no need for additional check
                        # Now, convert to integer
                        num = 0
                        for d in num_digits:
                            num = num *10 + d
                        mountains.add(num)
    # Return the sorted list
    return sorted(mountains)

def readints():
    import sys
    return list(map(int, sys.stdin.read().split()))

def main():
    mountains = generate_mountain_numbers()
    # Read input
    data = readints()
    T = data[0]
    idx =1
    for ti in range(1, T+1):
        A = data[idx]
        B = data[idx+1]
        M = data[idx+2]
        idx +=3
        # Find the range in mountains
        left = bisect.bisect_left(mountains, A)
        right = bisect.bisect_right(mountains, B)
        count =0
        subset = mountains[left:right]
        if M ==0:
            # If M=0, avoid division
            cnt =0
        else:
            for num in subset:
                if num % M ==0:
                    count +=1
        print(f"Case #{ti}: {count}")

if __name__ == "__main__":
    main()
```