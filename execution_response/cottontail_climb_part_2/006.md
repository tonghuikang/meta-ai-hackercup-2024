**Key Findings:**

1. **Odd Number of Digits:** Mountain numbers must have an odd number of digits, specifically \(2k + 1\) digits for some integer \(k \geq 0\).

2. **Non-Zero Digits:** All digits in the mountain number must be non-zero (i.e., digits 1 through 9).

3. **Monotonically Non-Decreasing First Half:** The first \(k + 1\) digits (including the middle digit) must be monotonically non-decreasing. This means each digit is greater than or equal to the previous one.

4. **Monotonically Non-Increasing Second Half:** The last \(k + 1\) digits must be monotonically non-increasing. Each digit is less than or equal to the previous one.

5. **Unique Middle Digit:** The middle digit (the \((k + 1)\)th digit) must be unique within the entire number. This implies that it appears only once.

6. **Efficient Generation:** Given the potential size of the range \([A, B]\) (up to \(10^{18}\)), it is efficient to precompute all possible mountain numbers within this range and store them in a sorted list. This allows for quick querying using binary search techniques.

7. **Divisibility Check:** For each test case, after identifying the relevant mountain numbers within \([A, B]\), count how many of these numbers are divisible by the given integer \(M\).

**Approach:**

1. **Precompute Mountain Numbers:**
   - Iterate through all possible lengths of mountain numbers (only odd lengths from 1 to 19 digits).
   - For each length, generate all valid mountain numbers by ensuring the first half is non-decreasing, the second half is non-increasing, and the middle digit is unique.
   - Store all generated mountain numbers in a sorted list for efficient querying.

2. **Handling Test Cases:**
   - For each test case with parameters \(A\), \(B\), and \(M\):
     - Use binary search to find the range of precomputed mountain numbers within \([A, B]\).
     - Iterate through this subset and count how many numbers are divisible by \(M\).

3. **Optimizations:**
   - Precompute and store all mountain numbers once, as they are common across all test cases.
   - Utilize efficient searching (binary search) to handle large ranges swiftly.

Below is the Python implementation based on the above approach:

```python
import sys
import bisect

def generate_mountain_numbers():
    mountain_numbers = []

    # Recursive function to generate non-decreasing sequences
    def generate_first_half(current, length, last_digit, numbers):
        if len(current) == length:
            numbers.append(current)
            return
        for digit in range(last_digit, 10):
            numbers.append(generate_first_half(current + [digit], length, digit, numbers))
            generate_first_half(current + [digit], length, digit, numbers)

    # Alternatively, use itertools to generate non-decreasing sequences
    from itertools import combinations_with_replacement

    for total_digits in range(1, 20, 2):  # Only odd lengths
        k = (total_digits - 1) // 2

        # Generate all possible first k+1 digits (non-decreasing)
        # Since digits are from 1 to 9, and first digit cannot be zero
        for first_half in combinations_with_replacement(range(1, 10), k + 1):
            # Ensure it is strictly non-decreasing
            # Since combinations_with_replacement already gives non-decreasing sequences
            # Now, ensure the middle digit is unique in the entire number
            middle_digit = first_half[-1]

            # To ensure uniqueness, we need to make sure that middle_digit does not appear in first k digits
            if middle_digit in first_half[:-1]:
                continue

            # Now, generate the second half (last k digits), which must be non-increasing and less than or equal to middle_digit
            # Also, middle_digit should be greater than the next digit to ensure uniqueness
            # So, next digit must be less than middle_digit
            def generate_second_half(current, remaining):
                if remaining == 0:
                    mountain = int(''.join(map(str, current)))
                    mountain_numbers.append(mountain)
                    return
                last = current[-1]
                for d in range(1, last + 1):
                    generate_second_half(current + [d], remaining - 1)

            # Initialize the second half with the middle digit
            generate_second_half(list(first_half), k)

    mountain_numbers.sort()
    return mountain_numbers

def generate_mountain_numbers_efficient():
    mountain_numbers = []

    from itertools import combinations_with_replacement, product

    for total_digits in range(1, 20, 2):
        k = (total_digits - 1) // 2

        # Generate all possible first k+1 digits (non-decreasing)
        # Use combinations_with_replacement to get non-decreasing sequences
        # Each sequence is a tuple
        first_half_sequences = list(combinations_with_replacement(range(1, 10), k + 1))

        for first_half in first_half_sequences:
            # Ensure the middle digit is unique in the entire number
            middle_digit = first_half[-1]
            if middle_digit in first_half[:-1]:
                continue  # Middle digit is not unique

            # Now, generate the second half: non-increasing, starting with middle_digit -1 down to 1
            # Because the next digit must be less than middle_digit to ensure uniqueness
            # And strictly less to ensure it's unique in entire number

            # The last k digits need to be non-increasing and <= middle_digit -1
            max_next_digit = middle_digit - 1
            if max_next_digit < 1:
                continue  # No valid second half

            # Generate all non-increasing sequences of length k with digits from 1 to max_next_digit
            # Using product with reversed digits to ensure non-increasing
            def generate_second_half(current, remaining, last_digit):
                if remaining == 0:
                    number = ''.join(map(str, first_half)) + ''.join(map(str, current))
                    mountain_numbers.append(int(number))
                    return
                for d in range(last_digit, 0, -1):
                    generate_second_half(current + [d], remaining - 1, d)

            generate_second_half([], k, max_next_digit)

    mountain_numbers.sort()
    return mountain_numbers

def main():
    import sys
    import bisect

    # Precompute all mountain numbers
    mountain_numbers = generate_mountain_numbers_efficient()
    # print(len(mountain_numbers))  # For debugging

    T = int(sys.stdin.readline())
    for case in range(1, T + 1):
        A_str, B_str, M_str = sys.stdin.readline().strip().split()
        A = int(A_str)
        B = int(B_str)
        M = int(M_str)

        # Find left and right indices using bisect
        left = bisect.bisect_left(mountain_numbers, A)
        right = bisect.bisect_right(mountain_numbers, B)

        # Count how many in mountain_numbers[left:right] are divisible by M
        count = 0
        for num in mountain_numbers[left:right]:
            if num % M == 0:
                count += 1

        print(f"Case #{case}: {count}")

if __name__ == "__main__":
    main()
```

**Explanation of the Code:**

1. **Generating Mountain Numbers:**
   - The `generate_mountain_numbers_efficient` function precomputes all possible mountain numbers up to 19 digits.
   - It iterates through all odd digit lengths (`1, 3, 5, ..., 19`).
   - For each length, it generates all possible non-decreasing sequences for the first half using `combinations_with_replacement`.
   - It ensures that the middle digit is unique by checking that it does not appear in the first \(k\) digits.
   - It then generates all possible non-increasing sequences for the second half, ensuring that each digit is strictly less than the middle digit to maintain uniqueness.
   - All valid mountain numbers are collected and sorted.

2. **Processing Test Cases:**
   - The `main` function reads the number of test cases.
   - For each test case, it reads the values \(A\), \(B\), and \(M\).
   - It uses binary search (`bisect_left` and `bisect_right`) to identify the range of mountain numbers within \([A, B]\).
   - It iterates through this subset and counts how many numbers are divisible by \(M\).
   - The result is printed in the specified format.

3. **Optimizations:**
   - Precomputing mountain numbers significantly reduces the computation required per test case.
   - Using `bisect` allows for efficient searching within the precomputed sorted list.
   - The recursive generation of the second half ensures adherence to the mountain number constraints without unnecessary computations.

**Note:** The provided implementation is optimized for clarity and understanding. Depending on the specific constraints and the environment in which it's run, further optimizations (such as memoization or more efficient generation techniques) might be applied to enhance performance.