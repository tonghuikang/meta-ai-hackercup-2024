**Key Findings:**

1. **Mountain Definition Constraints:**
   - **Length:** A mountain number must have an odd number of digits, specifically \(2k + 1\) for some integer \(k \geq 0\).
   - **Digits:** All digits must be non-zero.
   - **Monotonicity:**
     - The first \(k + 1\) digits should be monotonically non-decreasing.
     - The last \(k + 1\) digits should be monotonically non-increasing.
   - **Unique Middle Digit:** The middle digit must appear exactly once in the entire number.

2. **Generation Strategy:**
   - **Single-Digit Mountains:** All single-digit numbers from 1 to 9 are inherently mountains.
   - **Multi-Digit Mountains:** For lengths \(3, 5, \ldots, 19\):
     - **Middle Digit Selection:** Choose a middle digit (\(D_{\text{mid}}\)) from 2 to 9 (since \(D_{\text{mid}} = 1\) would not allow any preceding digits).
     - **First \(k\) Digits:** Generate all possible non-decreasing sequences of \(k\) digits where each digit is less than \(D_{\text{mid}}\).
     - **Last \(k\) Digits:** Generate all possible non-increasing sequences of \(k\) digits where each digit is less than \(D_{\text{mid}}\).
     - **Combination:** Combine the first \(k\) digits, the selected middle digit, and the last \(k\) digits to form valid mountain numbers.
     
3. **Efficiency Considerations:**
   - **Precomputation:** Since the total number of possible mountain numbers is relatively small (especially considering the constraints on digit values and length), precompute all mountain numbers up to \(10^{19}\) and sort them.
   - **Range Queries:** For each test case, perform binary searches to identify the subset of mountain numbers within the given range \([A, B]\).
   - **Divisibility Check:** Iterate through the identified subset and count how many are divisible by \(M\).
   
4. **Edge Cases Handling:**
   - **Zero Range:** Ensure that numbers like 0, which are not valid mountain numbers, are appropriately excluded.
   - **Minimum Length:** Handle single-digit mountains separately since they form the base case.

**Python Code:**

```python
import sys
import itertools
import bisect

def generate_mountain_numbers():
    mountains = []
    # Single-digit mountains
    for d in range(1, 10):
        mountains.append(d)
    # Multi-digit mountains
    for l in range(3, 20, 2):
        k = (l -1) //2
        for Dmid in range(2, 10):
            # Generate all non-decreasing sequences of length k with digits <= Dmid -1
            first_digits = list(itertools.combinations_with_replacement(range(1, Dmid), k))
            if k ==0:
                first_digits = [()]
            # Generate all non-increasing sequences of length k with digits <= Dmid -1
            last_digits = list(itertools.combinations_with_replacement(range(1, Dmid), k))
            if k ==0:
                last_digits = [()]
            for first in first_digits:
                for last in last_digits:
                    # Ensure that the last digits are non-increasing
                    last_sorted = sorted(last, reverse=True)
                    # Construct the number
                    number = 0
                    for d in first:
                        number = number *10 + d
                    number = number *10 + Dmid
                    for d in last_sorted:
                        number = number *10 + d
                    mountains.append(number)
    mountains = sorted(mountains)
    return mountains

def main():
    mountains = generate_mountain_numbers()
    input = sys.stdin.read().split()
    T = int(input[0])
    idx =1
    for t in range(1, T +1):
        A = int(input[idx])
        B = int(input[idx +1])
        M = int(input[idx +2])
        idx +=3
        # Find the range of mountains within [A,B]
        left = bisect.bisect_left(mountains, A)
        right = bisect.bisect_right(mountains, B)
        count =0
        for num in mountains[left:right]:
            if num % M ==0:
                count +=1
        print(f"Case #{t}: {count}")

if __name__ == "__main__":
    main()
```