To solve this problem, we'll generate all possible "mountain" numbers up to `1e18`, given the constraints. Since the length of a mountain number is an odd number up to 19 digits (because \(2k + 1 \leq 19\)), the total number of mountain numbers is manageable for precomputing.

**Key Steps:**

1. **Understanding the Mountain Number Properties:**
   - Length is an odd number \( (2k + 1) \).
   - Digits are non-zero.
   - The first \( k+1 \) digits are monotonically non-decreasing.
   - The last \( k+1 \) digits are monotonically non-increasing.
   - The middle digit is unique; it does not occur elsewhere in the number.

2. **Generating Mountain Numbers:**
   - Use recursion to build numbers digit by digit.
   - For each position, decide whether to continue increasing or start decreasing based on the position relative to the middle digit.
   - Ensure the uniqueness of the middle digit.
   - Keep track of used digits to prevent reuse of the middle digit.
   - Prune branches where the number exceeds `1e18`.

3. **Storing and Sorting the Mountain Numbers:**
   - Store the generated mountain numbers in a list.
   - Sort the list to enable efficient range queries using binary search.

4. **Processing Test Cases:**
   - For each test case, use binary search to find mountain numbers within the range `[A, B]`.
   - Count the numbers that are multiples of `M`.

5. **Optimizations:**
   - Early pruning in recursion if the current number exceeds `1e18`.
   - Using `bisect` module for efficient range queries.

**Python Code:**

```python
import sys
import threading
from bisect import bisect_left, bisect_right

def main():
    sys.setrecursionlimit(1 << 25)
    T = int(sys.stdin.readline().strip())
    test_cases = []
    max_M = 0
    for _ in range(T):
        A, B, M = map(int, sys.stdin.readline().strip().split())
        test_cases.append((A, B, M))
        max_M = max(max_M, M)
    mountain_numbers = []

    def generate_mountains(length, pos, is_increasing, last_digit, number_so_far, used_digits, middle_digit):
        if pos == length:
            mountain_numbers.append(number_so_far)
            return
        if pos < (length + 1) // 2:
            # Increasing part
            start_digit = last_digit
            for d in range(start_digit, 10):
                if d == 0:
                    continue
                new_number = number_so_far * 10 + d
                new_used_digits = used_digits.copy()
                new_used_digits.add(d)
                generate_mountains(length, pos + 1, True, d, new_number, new_used_digits, middle_digit)
        elif pos == (length + 1) // 2 - 1:
            # Middle digit position
            for d in range(last_digit, 10):
                if d == 0 or d in used_digits:
                    continue
                new_number = number_so_far * 10 + d
                new_used_digits = used_digits.copy()
                new_used_digits.add(d)
                generate_mountains(length, pos + 1, False, d, new_number, new_used_digits, d)
        else:
            # Decreasing part
            for d in range(min(last_digit, 9), 0, -1):
                if d == middle_digit:
                    continue
                new_number = number_so_far * 10 + d
                new_used_digits = used_digits.copy()
                new_used_digits.add(d)
                generate_mountains(length, pos + 1, False, d, new_number, new_used_digits, middle_digit)

    # Generate mountain numbers of lengths 1 to 19 (odd numbers)
    for length in range(1, 20, 2):
        def generate(length):
            def helper(pos, is_increasing, last_digit, number_so_far, used_digits, middle_digit):
                if pos == length:
                    if number_so_far <= 1e18:
                        mountain_numbers.append(number_so_far)
                    return
                if pos < (length + 1) // 2:
                    # Increasing part
                    start_digit = last_digit
                    for d in range(start_digit, 10):
                        if d == 0:
                            continue
                        new_number = number_so_far * 10 + d
                        new_used_digits = used_digits.copy()
                        new_used_digits.add(d)
                        helper(pos + 1, True, d, new_number, new_used_digits, middle_digit)
                elif pos == (length + 1) // 2:
                    # Middle digit position
                    for d in range(last_digit, 10):
                        if d == 0 or d in used_digits:
                            continue
                        new_number = number_so_far * 10 + d
                        new_used_digits = used_digits.copy()
                        new_used_digits.add(d)
                        helper(pos + 1, False, d, new_number, new_used_digits, d)
                else:
                    # Decreasing part
                    for d in range(min(last_digit,9), 0, -1):
                        if d == middle_digit:
                            continue
                        new_number = number_so_far * 10 + d
                        new_used_digits = used_digits.copy()
                        new_used_digits.add(d)
                        helper(pos + 1, False, d, new_number, new_used_digits, middle_digit)
            helper(0, True, 1, 0, set(), -1)

        generate(length)

    mountain_numbers = sorted(mountain_numbers)

    for idx, (A, B, M) in enumerate(test_cases, 1):
        left = bisect_left(mountain_numbers, A)
        right = bisect_right(mountain_numbers, B)
        count = 0
        for num in mountain_numbers[left:right]:
            if num % M == 0:
                count += 1
        print(f"Case #{idx}: {count}")

threading.Thread(target=main).start()
```

**Explanation:**

- **Recursion Function:** `helper` recursively builds mountain numbers digit by digit, ensuring all the given conditions.
- **Mountain Number Generation:** The numbers are generated up to `1e18`, and stored in `mountain_numbers`.
- **Sorting:** The list `mountain_numbers` is sorted to allow efficient searching.
- **Processing Each Test Case:**
  - **Binary Search:** Use `bisect_left` and `bisect_right` to find mountain numbers within `[A, B]`.
  - **Counting Multiples of `M`:** Iterate through the selected numbers and count how many are divisible by `M`.
- **Output Format:** Prints the result in the required format for each test case.

**Note:** The code uses multithreading (`threading.Thread(target=main).start()`) to handle recursion depth limitations in online judges or specific environments that might limit stack size for the main thread.