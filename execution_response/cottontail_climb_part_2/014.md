**Key Findings:**

1. **Mountain Number Structure:**
   - **Odd Number of Digits:** Mountain numbers have an odd number of digits, specifically \(2k + 1\) for some integer \(k \geq 0\).
   - **Non-Zero Digits:** No digit in the number can be zero.
   - **Monotonic Sequences:** The first \(k+1\) digits must be non-decreasing, and the last \(k+1\) digits must be non-increasing.
   - **Unique Middle Digit:** The middle digit (the \((k+1)\)th digit) must appear exactly once in the entire number.

2. **Generation Strategy:**
   - **Iterate Over Possible Lengths:** For each odd number of digits from 1 to 19, generate all possible mountain numbers.
   - **Middle Digit Selection:** For numbers with more than one digit, iterate over possible middle digits (2 to 9) since the middle digit must be unique and greater than its adjacent digits.
   - **First and Last Halves:** 
     - **First Half:** Generate all non-decreasing sequences of \(k\) digits where each digit is less than the middle digit.
     - **Last Half:** Generate all non-increasing sequences of \(k\) digits where each digit is less than the middle digit.
   - **Combine Halves:** Combine the first half, middle digit, and last half to form complete mountain numbers.

3. **Efficiency Considerations:**
   - **Precomputation:** Generate all possible mountain numbers beforehand since their total count is manageable (up to around 1 million).
   - **Sorting:** Sort the list of mountain numbers to allow efficient range queries using binary search.
   - **Handling Multiple Test Cases:** For each test case, use binary search to identify the relevant subset of mountain numbers within the range \([A, B]\) and count those divisible by \(M\).

4. **Optimizations:**
   - **Single-Digit Mountains:** Directly handle single-digit numbers as they are trivially valid mountain numbers.
   - **Early Filtering:** When generating sequences, ensure that all digits meet the necessary constraints to reduce unnecessary computations.

**Python Code:**

```python
import sys
import bisect
from itertools import combinations_with_replacement, product

def generate_non_decreasing_sequences(k, max_digit):
    """
    Generate all non-decreasing sequences of length k with digits from 1 to max_digit -1
    """
    if k == 0:
        return [()]
    # Use combinations with replacement
    return list(combinations_with_replacement(range(1, max_digit), k))

def generate_non_increasing_sequences(k, max_digit):
    """
    Generate all non-increasing sequences of length k with digits from 1 to max_digit -1
    """
    if k == 0:
        return [()]
    # Generate combinations with replacement in reverse order
    sequences = list(combinations_with_replacement(range(1, max_digit), k))
    # For each combination, sort descending to make non-increasing
    return [tuple(sorted(seq, reverse=True)) for seq in sequences]

def generate_all_mountains():
    mountains = []
    # Lengths: 1,3,5,...,19
    for n in range(1, 20, 2):
        k = (n -1)//2
        if k ==0:
            # Single-digit mountains
            for d in range(1,10):
                mountains.append(d)
        else:
            # For k >=1, generate mountains
            for peak in range(2,10):
                # First k digits: non-decreasing sequences with digits < peak
                first_half_seqs = generate_non_decreasing_sequences(k, peak)
                if not first_half_seqs:
                    continue
                # Last k digits: non-increasing sequences with digits < peak
                last_half_seqs = generate_non_increasing_sequences(k, peak)
                if not last_half_seqs:
                    continue
                # Combine all possible sequences
                for first in first_half_seqs:
                    for last in last_half_seqs:
                        # To ensure that peak appears only once, check that peak doesn't appear in first or last
                        if peak in first or peak in last:
                            continue
                        # Build the number
                        number_digits = first + (peak,) + last
                        # Convert to integer
                        number = 0
                        for d in number_digits:
                            number = number * 10 + d
                        mountains.append(number)
    # Sort the mountains
    mountains.sort()
    return mountains

def main():
    import sys
    import threading
    def run():
        mountains = generate_all_mountains()
        T = int(sys.stdin.readline())
        for case in range(1, T+1):
            A, B, M = map(int, sys.stdin.readline().split())
            # Find left index: first mountain >= A
            left = bisect.bisect_left(mountains, A)
            # Find right index: first mountain > B
            right = bisect.bisect_right(mountains, B)
            count =0
            # Iterate through mountain[left:right] and count divisible by M
            if M ==1:
                count = right - left
            else:
                # To optimize, iterate and count
                for num in mountains[left:right]:
                    if num % M ==0:
                        count +=1
            print(f"Case #{case}: {count}")

    threading.Thread(target=run).start()

if __name__ == "__main__":
    main()
```