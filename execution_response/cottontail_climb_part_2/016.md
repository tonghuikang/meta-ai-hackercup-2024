To solve the problem of counting "mountain" numbers within a given range \([A, B]\) that are divisible by \(M\), we can follow these key steps:

1. **Understanding Mountain Numbers:**
   - Mountain numbers have an odd number of digits (\(2k + 1\)).
   - All digits are non-zero.
   - The first \(k + 1\) digits are non-decreasing.
   - The last \(k + 1\) digits are non-increasing.
   - The middle digit is strictly greater than its immediate neighbors, making it unique.

2. **Generating Mountain Numbers:**
   - Iterate through possible digit lengths (1, 3, 5, ..., up to 17 digits since \(B \leq 10^{18}\)).
   - For each length, generate the first half of the number ensuring they are non-decreasing.
   - Choose a peak digit that is greater than the last digit of the first half.
   - Generate the second half ensuring they are non-increasing starting from the peak.
   - Collect all such generated numbers, ensuring there are no leading zeros.

3. **Processing Test Cases:**
   - For each test case, use binary search to find mountain numbers within the range \([A, B]\).
   - Count how many of these are divisible by \(M\).

This approach is efficient as the total count of mountain numbers is manageable (on the order of hundreds of thousands), making it feasible to precompute and process within the given constraints.

Below is the Python implementation encapsulating the above logic:

```python
import sys
import bisect

def generate_mountain_numbers():
    # List to store mountain numbers
    mountains = []

    # Function to generate non-decreasing sequences
    def generate_non_decreasing(length, start, current, sequences):
        if len(current) == length:
            sequences.append(current.copy())
            return
        for digit in range(start, 10):
            current.append(digit)
            generate_non_decreasing(length, digit, current, sequences)
            current.pop()

    # Function to generate non-increasing sequences
    def generate_non_increasing(length, max_digit, current, sequences):
        if len(current) == length:
            sequences.append(current.copy())
            return
        for digit in range(1, max_digit + 1):
            current.append(digit)
            generate_non_increasing(length, digit, current, sequences)
            current.pop()

    # Generate mountain numbers for each odd digit length
    for total_digits in range(1, 19, 2):  # 1,3,5,...,17
        k = total_digits // 2
        first_half_length = k + 1
        second_half_length = k

        # Generate all non-decreasing first_half_length digits starting from 1 to 9
        sequences = []
        generate_non_decreasing(first_half_length, 1, [], sequences)

        for first_half in sequences:
            peak = first_half[-1]
            if k == 0:
                # Single digit mountain
                number = peak
                mountains.append(number)
                continue

            # The peak must be greater than the previous digit
            # and we need to generate second_half_length digits <= peak -1
            # because the middle digit must be > the next digit
            # But from the problem examples, it seems the middle digit should be > next digit
            # So the digit after peak should be <= peak -1
            # Thus, the possible second half sequences are non-increasing sequences
            # of length second_half_length with digits <= peak -1 and >=1
            if peak == 1:
                # No possible second half, since digits must be >=1 and <=0
                continue
            max_second = peak -1
            second_sequences = []
            generate_non_increasing(second_half_length, max_second, [], second_sequences)
            for second_half in second_sequences:
                # Combine first_half and second_half
                number_digits = first_half + second_half
                # Convert to integer
                number = 0
                for d in number_digits:
                    number = number * 10 + d
                mountains.append(number)

    mountains = sorted(mountains)
    return mountains

def main():
    import sys
    import threading

    def run():
        mountains = generate_mountain_numbers()
        T = int(sys.stdin.readline())
        for case in range(1, T +1):
            A, B, M = map(int, sys.stdin.readline().strip().split())
            # Find the left and right indices
            left = bisect.bisect_left(mountains, A)
            right = bisect.bisect_right(mountains, B)
            count = 0
            for num in mountains[left:right]:
                if num % M ==0:
                    count +=1
            print(f"Case #{case}: {count}")

    threading.Thread(target=run).start()

if __name__ == "__main__":
    main()
```