**Key Findings:**

1. **Mountain Number Definition**: A mountain number has an odd number of digits (\(2k + 1\)), all digits are non-zero, the first \(k+1\) digits are non-decreasing, the last \(k+1\) digits are non-increasing, and the middle digit appears exactly once in the entire number.

2. **Generation Strategy**:
   - **Digit Lengths**: Iterate through all possible odd digit lengths from 1 to 19 (since \(B \leq 10^{18}\)).
   - **Middle Digit**: For each valid digit length, iterate through possible middle digits (2 to 9). The middle digit must be unique, meaning it doesn't appear in any other position.
   - **First Half**: Generate all non-decreasing sequences for the first \(k\) digits where each digit is less than the middle digit.
   - **Second Half**: Generate all non-increasing sequences for the last \(k\) digits where each digit is less than the middle digit.
   - **Combination**: Combine the first half, middle digit, and second half to form valid mountain numbers.

3. **Efficiency Considerations**:
   - **Precomputation**: Precompute all possible mountain numbers up to 19 digits and store them in a sorted list. This allows for efficient querying using binary search.
   - **Test Cases**: For each test case, use binary search to find the range of mountain numbers within \([A, B]\) and count how many are divisible by \(M\).

4. **Edge Cases**:
   - Single-digit numbers (1-9) are valid mountains.
   - When the middle digit is 1, it cannot appear in the first \(k\) digits for digit lengths greater than 1.
   
5. **Implementation Details**:
   - Use recursive backtracking to generate non-decreasing and non-increasing sequences.
   - Convert digit sequences to integers and store them in a sorted list for efficient access.
   - Utilize Python's `bisect` module to perform efficient range searches.

```python
import sys
import bisect

def generate_non_decreasing(length, min_digit, max_digit):
    sequences = []

    def backtrack(pos, current, last):
        if pos == length:
            sequences.append(list(current))
            return
        for d in range(last, max_digit +1):
            current.append(d)
            backtrack(pos +1, current, d)
            current.pop()

    backtrack(0, [], min_digit)
    return sequences

def generate_non_increasing(length, max_digit, min_digit):
    sequences = []

    def backtrack(pos, current, last):
        if pos == length:
            sequences.append(list(current))
            return
        for d in range(last, min_digit -1, -1):
            current.append(d)
            backtrack(pos +1, current, d)
            current.pop()

    backtrack(0, [], max_digit)
    return sequences

def generate_mountains():
    mountains = set()

    # Add single-digit mountains
    mountains.update(range(1,10))

    for total_digits in range(3, 20, 2):
        k = (total_digits -1)//2
        for Dmiddle in range(2, 10):
            # Generate all non-decreasing sequences for the first k digits
            left_sequences = generate_non_decreasing(k, 1, Dmiddle -1)
            # Generate all non-increasing sequences for the last k digits
            right_sequences = generate_non_increasing(k, Dmiddle -1, 1)
            for left in left_sequences:
                for right in right_sequences:
                    # Combine to form the full number
                    number_digits = left + [Dmiddle] + right
                    number = 0
                    for d in number_digits:
                        number = number *10 + d
                    mountains.add(number)
    return sorted(mountains)

def main():
    mountains = generate_mountains()
    T = int(sys.stdin.readline())
    for case in range(1, T+1):
        line = ''
        while line.strip() == '':
            line = sys.stdin.readline()
        A, B, M = map(int, line.strip().split())
        # Find the left and right indices using bisect
        left_idx = bisect.bisect_left(mountains, A)
        right_idx = bisect.bisect_right(mountains, B)
        count = 0
        for m in mountains[left_idx:right_idx]:
            if m % M ==0:
                count +=1
        print(f"Case #{case}: {count}")

if __name__ == "__main__":
    main()
```