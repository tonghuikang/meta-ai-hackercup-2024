**Key Findings:**

1. **Mountain Number Characteristics:**
   - **Odd Number of Digits:** Mountain numbers must have \(2k + 1\) digits.
   - **No Zero Digits:** All digits must be from 1 to 9.
   - **Monotonically Non-decreasing First Half:** The first \(k+1\) digits should be non-decreasing.
   - **Monotonically Non-increasing Second Half:** The last \(k+1\) digits should be non-increasing.
   - **Unique Middle Digit:** The central digit must be strictly greater than its adjacent digits.

2. **Generating Mountain Numbers:**
   - Due to the constraints, especially the unique middle digit and non-zero requirements, the total number of mountain numbers up to \(10^{18}\) is manageable.
   - A recursive approach can be utilized to generate all possible mountain numbers by constructing the first half and mirroring it appropriately.

3. **Efficient Query Handling:**
   - Precompute all mountain numbers and store them in a sorted list.
   - For each test case, utilize binary search to identify the range of mountain numbers within \([A, B]\).
   - Iterate through the identified subset and count those divisible by \(M\).

4. **Optimization Considerations:**
   - Since \(T\) can be up to 95 and \(M\) up to \(10^9\), precomputing divisibility for all possible \(M\) is infeasible. Instead, handle divisibility checks on a per-test-case basis.
   - This approach ensures that the solution remains efficient even for the upper bounds of the input constraints.

**Python Code:**

```python
import sys
import bisect

def generate_mountain_numbers():
    mountains = []

    # Function to generate non-decreasing sequences without zero
    def generate_first_half(length, current, last_digit):
        if len(current) == length:
            return [current]
        sequences = []
        for digit in range(last_digit, 10):
            if digit == 0:
                continue
            sequences.extend(generate_first_half(length, current + [digit], digit))
        return sequences

    # Function to generate non-increasing sequences without zero
    def generate_second_half(length, current, last_digit):
        if len(current) == length:
            return [current]
        sequences = []
        for digit in range(last_digit, 0, -1):
            sequences.extend(generate_second_half(length, current + [digit], digit))
        return sequences

    # Generate mountain numbers for all possible odd lengths
    for total_length in range(1, 19+1, 2):  # up to 19 digits
        k = total_length // 2
        first_half_length = k + 1
        # Generate all non-decreasing sequences for the first half
        first_halves = generate_first_half(first_half_length, [], 1)
        for first_half in first_halves:
            peak = first_half[-1]
            # The peak must be greater than its previous digit if k > 0
            if k > 0 and first_half[-2] >= peak:
                continue  # Peak is not unique
            # Generate the second half which is non-increasing and starts with peak
            second_half_length = k
            second_halves = generate_second_half(second_half_length, [], peak)
            for second_half in second_halves:
                number_digits = first_half + second_half[::-1]
                number = int(''.join(map(str, number_digits)))
                mountains.append(number)
    mountains = sorted(set(mountains))
    return mountains

def main():
    import sys
    import threading

    def run():
        mountains = generate_mountain_numbers()
        T = int(sys.stdin.readline())
        for case in range(1, T + 1):
            A_str, B_str, M_str = sys.stdin.readline().strip().split()
            A = int(A_str)
            B = int(B_str)
            M = int(M_str)
            # Find the range in mountains
            left = bisect.bisect_left(mountains, A)
            right = bisect.bisect_right(mountains, B)
            count = 0
            for num in mountains[left:right]:
                if num % M == 0:
                    count += 1
            print(f"Case #{case}: {count}")

    threading.Thread(target=run,).start()

if __name__ == "__main__":
    main()
```