**Key Findings:**

1. **Mountain Number Structure:**
   - A mountain number has an odd number of digits \(2k + 1\) with all digits non-zero.
   - The first \(k+1\) digits are monotonically non-decreasing.
   - The last \(k+1\) digits are monotonically non-increasing.
   - The middle digit is unique (appears only once in the entire number).

2. **Generation Strategy:**
   - For each possible odd length from 1 to 19 digits:
     - If the length is 1, the mountain numbers are simply digits from 1 to 9.
     - For longer lengths, iterate through possible middle digits (1 to 9).
     - Generate all valid non-decreasing sequences for the first half and non-increasing sequences for the second half, ensuring the middle digit is unique.
   - Use combinatorial methods (`itertools.combinations_with_replacement`) to efficiently generate sequences.

3. **Efficiency Considerations:**
   - Precompute and store all mountain numbers up to \(10^{18}\) in a sorted list.
   - Convert this list to a NumPy array for efficient vectorized operations.
   - For each test case, use binary search to identify the relevant range of mountain numbers and count those divisible by \(M\) using NumPy's optimized modulo operations.

4. **Handling Multiple Test Cases:**
   - By precomputing the mountain numbers once, we can efficiently handle up to 95 test cases.
   - Leveraging NumPy's capabilities ensures that even with large datasets, the computations remain performant.

**Python Code:**

```python
import sys
import itertools
import numpy as np

def generate_mountain_numbers():
    mountain_numbers = []

    # Length 1
    for d in range(1,10):
        mountain_numbers.append(d)

    # Lengths 3,5,...,19
    for L in range(3, 20, 2):
        k = (L -1)//2
        for d in range(1,10):
            if d ==1 and k >0:
                continue  # No digits less than 1
            # Generate first k digits: non-decreasing from 1 to d-1
            if k ==0:
                first_seqs = [()]
            else:
                first_seqs = list(itertools.combinations_with_replacement(range(1,d), k))
                if not first_seqs:
                    continue
            # Generate last k digits: non-increasing from d-1 to 1
                # Which is reverse of non-decreasing from 1 to d-1
                last_seqs = [seq[::-1] for seq in itertools.combinations_with_replacement(range(1,d), k)]
                if not last_seqs:
                    continue
            for first in first_seqs:
                for last in last_seqs:
                    digits = first + (d,) + last
                    num = 0
                    for digit in digits:
                        num = num *10 + digit
                    mountain_numbers.append(num)
    return mountain_numbers

def main():
    mountain_numbers = generate_mountain_numbers()
    mountain_numbers_sorted = sorted(mountain_numbers)
    numbers = np.array(mountain_numbers_sorted, dtype=np.int64)

    T = int(sys.stdin.readline())
    for case in range(1, T+1):
        line = ''
        while line.strip() == '':
            line = sys.stdin.readline()
        A_str, B_str, M_str = line.strip().split()
        A = int(A_str)
        B = int(B_str)
        M = int(M_str)
        idx_a = np.searchsorted(numbers, A, side='left')
        idx_b = np.searchsorted(numbers, B, side='right')
        subset = numbers[idx_a:idx_b]
        if M ==1:
            count = subset.size
        else:
            # To handle large M, ensure M is within int64
            subset_mod = subset % M
            count = np.count_nonzero(subset_mod ==0)
        print(f"Case #{case}: {count}")

if __name__ == "__main__":
    main()
```