**Key Findings:**

1. **Mountain Number Characteristics:** A mountain number must have an odd number of digits (\(2k + 1\)), all digits are non-zero, the first \(k+1\) digits are monotonically non-decreasing, the last \(k+1\) digits are monotonically non-increasing, and the middle digit is strictly greater than its adjacent digits.

2. **Precomputation Strategy:** Given the large possible range (\(0 \leq A, B \leq 10^{18}\)), directly iterating through all numbers in the range for each test case is impractical. Instead, precompute all possible mountain numbers up to \(10^{18}\) and store them in a sorted list. This allows efficient querying for each test case using binary search.

3. **Recursive Generation:** To generate all mountain numbers, use a recursive backtracking approach. For each possible number of digits (from 1 to 19, considering only odd lengths), build the number by ensuring the digits adhere to the mountain criteria:
   - **Left Half (Including Middle):** Monotonically non-decreasing.
   - **Middle Digit:** Must be strictly greater than its adjacent digits.
   - **Right Half:** Monotonically non-increasing.

4. **Divisibility Check:** After precomputing and sorting all mountain numbers, for each test case, perform a binary search to find the range of mountain numbers within \([A, B]\). Then, iterate through this subset and count how many are divisible by \(M\).

5. **Efficiency Considerations:** Given that the total number of mountain numbers is relatively small (due to strict digit constraints), this approach is computationally feasible even with up to 95 test cases.

**Python Code:**

```python
import sys
import bisect

def generate_mountain_numbers():
    mountains = []

    def backtrack(n_digits, current_digits, pos, is_increasing, peak_pos, last_digit):
        if pos == n_digits:
            # Check if it's a valid mountain
            mountains.append(int(''.join(map(str, current_digits))))
            return
        if pos < peak_pos:
            # Left side: non-decreasing
            start = last_digit
            for d in range(start, 10):
                if d == 0:
                    continue
                current_digits[pos] = d
                backtrack(n_digits, current_digits, pos + 1, True, peak_pos, d)
        elif pos == peak_pos:
            # Peak: must be greater than previous digit
            for d in range(last_digit + 1, 10):
                if d == 0:
                    continue
                current_digits[pos] = d
                backtrack(n_digits, current_digits, pos + 1, False, peak_pos, d)
        else:
            # Right side: non-increasing
            start = current_digits[pos - 1]
            for d in range(1, current_digits[pos -1]+1):
                if d == 0:
                    continue
                current_digits[pos] = d
                backtrack(n_digits, current_digits, pos + 1, False, peak_pos, d)

    for total_digits in range(1, 20, 2):
        peak = total_digits // 2
        current = [0] * total_digits
        backtrack(total_digits, current, 0, True, peak, 0)

    mountains = sorted(mountains)
    return mountains

def main():
    input = sys.stdin.read().split()
    T = int(input[0])
    index = 1
    mountains = generate_mountain_numbers()
    for test_case in range(1, T + 1):
        A = int(input[index])
        B = int(input[index + 1])
        M = int(input[index + 2])
        index += 3
        # Find the left and right indices using bisect
        left = bisect.bisect_left(mountains, A)
        right = bisect.bisect_right(mountains, B)
        count = 0
        for num in mountains[left:right]:
            if num % M == 0:
                count += 1
        print(f"Case #{test_case}: {count}")

if __name__ == "__main__":
    main()
```