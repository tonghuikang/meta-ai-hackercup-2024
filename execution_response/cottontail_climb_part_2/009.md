**Key Findings:**

1. **Mountain Number Definition**: A mountain number has an odd number of digits \(2k + 1\), all digits are non-zero, the first \(k+1\) digits are monotonically non-decreasing, the last \(k+1\) digits are monotonically non-increasing, and the middle digit is unique (appears exactly once).

2. **Generation Strategy**:
    - **Odd Lengths Only**: Only numbers with odd numbers of digits (1, 3, 5, ..., 19) are considered.
    - **Middle Digit Uniqueness**: For each possible middle digit (1-9), generate all possible non-decreasing sequences for the first \(k\) digits and all possible non-increasing sequences for the last \(k\) digits, ensuring no digit equals the middle digit except for its unique position.
    - **Combinatorial Generation**: Utilize combinations with replacement to efficiently generate valid sequences for both the ascending and descending parts of the mountain.

3. **Efficiency Considerations**:
    - **Precomputation**: Generate and store all possible mountain numbers up to \(10^{19}\) before processing test cases. This allows for quick range queries using binary search.
    - **Range Queries**: For each test case, use binary search to identify mountain numbers within the specified range \([A, B]\) and then count those divisible by \(M\).
    - **Optimized Iteration**: Given the manageable number of mountain numbers, iterating through them for each test case is computationally feasible even with the upper constraints.

4. **Edge Cases**:
    - **Single-Digit Mountains**: All single-digit numbers (1-9) are valid mountains.
    - **No Zeros Allowed**: Ensure that no mountain number contains the digit zero.
    - **Uniqueness of Middle Digit**: Verify that the middle digit does not repeat in the number.

The following Python code implements the above strategy:

```python
import sys
import bisect
from itertools import combinations_with_replacement

def generate_mountain_numbers():
    mountain_numbers = set()
    for k in range(0, 10):  # L=2k+1=1,...,19
        L = 2 * k + 1
        if L > 19:
            break
        for m_digit in range(1, 10):
            if k == 0:
                mountain_numbers.add(m_digit)
                continue
            if m_digit == 1 and k > 0:
                # No digits less than 1, skip
                continue
            # Generate all non-decreasing sequences of first k digits, digits 1 to m_digit-1
            first_digits = list(combinations_with_replacement(range(1, m_digit), k))
            if not first_digits:
                continue
            # Similarly for last k digits:
            last_digits = list(combinations_with_replacement(range(1, m_digit), k))
            if not last_digits:
                continue
            for fd in first_digits:
                for ld in last_digits:
                    # Ensure that last digits are non-increasing by reversing
                    ld_rev = ld[::-1]
                    # Combine
                    num_digits = list(fd) + [m_digit] + list(ld_rev)
                    # Convert to integer
                    num = 0
                    for d in num_digits:
                        num = num * 10 + d
                    mountain_numbers.add(num)
    return sorted(mountain_numbers)

def main():
    import sys
    import threading

    def run():
        mountain_numbers = generate_mountain_numbers()
        T = int(sys.stdin.readline())
        for case in range(1, T + 1):
            A_str, B_str, M_str = sys.stdin.readline().strip().split()
            A = int(A_str)
            B = int(B_str)
            M = int(M_str)
            # Find the left and right indices
            left = bisect.bisect_left(mountain_numbers, A)
            right = bisect.bisect_right(mountain_numbers, B)
            count = 0
            for num in mountain_numbers[left:right]:
                if num % M == 0:
                    count += 1
            print(f"Case #{case}: {count}")

    threading.Thread(target=run,).start()

if __name__ == "__main__":
    main()
```