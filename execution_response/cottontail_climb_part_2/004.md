**Key Findings:**

1. **Definition of Mountain Numbers**:
   - Mountain numbers have an odd number of digits (\(2k + 1\)), with no zeros.
   - The first \(k+1\) digits are non-decreasing, and the last \(k+1\) digits are non-increasing.
   - The middle digit must be unique, meaning it appears exactly once in the entire number.

2. **Generating Mountain Numbers**:
   - Iterate through all possible odd lengths (1, 3, 5, ..., 19 digits).
   - For each length, determine the middle digit \(d\) (1 through 9).
   - Generate all possible non-decreasing sequences for the first \(k\) digits (where \(k = \frac{L-1}{2}\)) with digits less than \(d\).
   - Similarly, generate all possible non-increasing sequences for the last \(k\) digits with digits less than \(d\).
   - Combine these sequences with the middle digit to form valid mountain numbers.
   - Ensure that the middle digit appears only once in the entire number.

3. **Counting Valid Numbers**:
   - Precompute and sort all mountain numbers up to \(10^{18}\).
   - For each test case, perform a binary search to find the range of mountain numbers between \(A\) and \(B\).
   - Iterate through this subset and count how many are divisible by \(M\).

4. **Efficiency Considerations**:
   - The total number of mountain numbers is manageable (on the order of \(10^5\)), allowing for efficient processing even with multiple test cases.
   - Utilizing sorted lists and binary search optimizes the range queries.

**Python Code:**

```python
import sys
import bisect

def generate_non_decreasing_sequences(k, max_digit):
    if k == 0:
        return [[]]
    sequences = [[]]
    for _ in range(k):
        new_sequences = []
        for seq in sequences:
            start = seq[-1] if seq else 1
            for digit in range(start, max_digit +1):
                new_sequences.append(seq + [digit])
        sequences = new_sequences
    return sequences

def generate_non_increasing_sequences(k, max_digit):
    if k == 0:
        return [[]]
    sequences = [[]]
    for _ in range(k):
        new_sequences = []
        for seq in sequences:
            start = seq[-1] if seq else max_digit
            for digit in range(1, start +1):
                new_sequences.append(seq + [digit])
        sequences = new_sequences
    return sequences

def generate_mountain_numbers():
    mountain_numbers = []
    # Lengths: 1,3,5,...,19
    for L in range(1, 20, 2):
        k = (L -1)//2
        for d in range(1,10):
            if k ==0:
                # Single-digit mountains
                mountain_numbers.append(d)
            else:
                if d-1 <1:
                    continue
                # Generate first k digits: non-decreasing, digits 1 to d-1
                first_seqs = generate_non_decreasing_sequences(k, d-1)
                if not first_seqs:
                    continue
                # Generate last k digits: non-increasing, digits 1 to d-1
                last_seqs = generate_non_increasing_sequences(k, d-1)
                if not last_seqs:
                    continue
                # Combine
                for first in first_seqs:
                    for last in last_seqs:
                        number_digits = first + [d] + last
                        number = int(''.join(map(str, number_digits)))
                        mountain_numbers.append(number)
    mountain_numbers = sorted(mountain_numbers)
    return mountain_numbers

def main():
    import sys
    import threading

    def run():
        mountain_numbers = generate_mountain_numbers()
        T = int(sys.stdin.readline())
        for case in range(1, T+1):
            A_str, B_str, M_str = sys.stdin.readline().strip().split()
            A = int(A_str)
            B = int(B_str)
            M = int(M_str)
            # Find left and right indices
            left = bisect.bisect_left(mountain_numbers, A)
            right = bisect.bisect_right(mountain_numbers, B)
            count = 0
            # Iterate through the relevant slice
            for num in mountain_numbers[left:right]:
                if num % M ==0:
                    count +=1
            print(f"Case #{case}: {count}")
        
    threading.Thread(target=run).start()

if __name__ == "__main__":
    main()
```