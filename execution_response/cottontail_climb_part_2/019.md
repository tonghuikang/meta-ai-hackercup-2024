**Key Findings:**

1. **Mountain Number Characteristics:**
   - **Length:** Mountain numbers have an odd number of digits, specifically \(2k + 1\) for some integer \(k \geq 0\).
   - **Digit Constraints:** No digit is zero; all digits range from 1 to 9.
   - **Monotonic Sequences:** The first \(k+1\) digits are non-decreasing, and the last \(k+1\) digits are non-increasing.
   - **Unique Middle Digit:** The central digit must be unique, serving as the peak of the mountain.

2. **Approach to Solve the Problem:**
   - **Preprocessing:** 
     - Generate all possible mountain numbers within the maximum digit limit (up to 19 digits since \(10^{18}\) has 19 digits).
     - Utilize combinatorial methods to construct non-decreasing and non-increasing sequences efficiently.
   - **Handling Multiple Test Cases Efficiently:**
     - Since there can be up to 95 test cases, precompute and store all mountain numbers in a sorted list.
     - For each test case, perform binary searches to find the range of mountain numbers between \(A\) and \(B\).
     - Iterate through the relevant subset to count how many are divisible by \(M\).
   - **Optimizations:**
     - Avoid generating mountain numbers with leading zeros.
     - Leverage the sorted nature of the mountain numbers to perform efficient range queries.

3. **Implementation Considerations:**
   - Use memoization or dynamic programming to avoid redundant computations when generating sequences.
   - Ensure that the generation of mountain numbers does not exceed the constraints, especially regarding the uniqueness of the middle digit.
   - Utilize efficient data structures like lists and binary search algorithms to handle large datasets within the time constraints.

With these findings, the following Python code efficiently generates all possible mountain numbers, sorts them, and processes each test case to determine the count of valid mountains within the specified range that are divisible by \(M\).

```python
import sys
import bisect

def generate_mountain_numbers():
    mountains = []

    # Maximum number of digits is 19 (since B <= 10^18)
    for k in range(0, 10):  # since 2k+1 <=19 when k<=9
        length = 2 * k + 1
        if length > 19:
            continue

        # Generate all possible non-decreasing sequences for the first k+1 digits
        def backtrack_first(pos, current, last_digit):
            if pos == k +1:
                # Now generate the last k+1 digits, which should be non-increasing and starts with current[-1]
                middle_digit = current[-1]
                backtrack_last(0, current, [middle_digit], middle_digit)
                return
            for d in range(last_digit, 10):
                if d ==0:
                    continue
                current.append(d)
                backtrack_first(pos +1, current, d)
                current.pop()

        # Generate all possible non-increasing sequences for the last k+1 digits
        def backtrack_last(pos, first_part, current_last, last_digit):
            if pos == k +1:
                # Combine first_part and current_last, ensuring uniqueness of middle digit
                # First part has k+1 digits, current_last has k+1 digits with first being the middle digit
                full_digits = first_part + current_last[1:]
                # Check uniqueness of middle digit
                # Ensure that the middle digit is unique, meaning it's greater than its neighbors
                # However, according to the problem, "the middle digit is unique" likely means it's distinct.
                # So we ensure that the middle digit is greater than the digits before and after
                mid = k
                if full_digits[mid] > full_digits[mid -1] and full_digits[mid] > full_digits[mid +1]:
                    # Convert to number
                    number = 0
                    for d in full_digits:
                        number = number *10 + d
                    mountains.append(number)
                return
            for d in range(1, last_digit+1):
                current_last.append(d)
                backtrack_last(pos +1, first_part, current_last, d)
                current_last.pop()

        backtrack_first(0, [], 1)

    mountains = sorted(set(mountains))
    return mountains

def main():
    import sys
    import threading

    def run():
        mountains = generate_mountain_numbers()
        T = int(sys.stdin.readline())
        for case in range(1, T+1):
            A_str, B_str, M_str = sys.stdin.readline().strip().split()
            A = int(A_str)
            B = int(B_str)
            M = int(M_str)
            # Find the indices of mountains >=A and <=B
            left = bisect.bisect_left(mountains, A)
            right = bisect.bisect_right(mountains, B)
            count = 0
            for num in mountains[left:right]:
                if num % M ==0:
                    count +=1
            print(f"Case #{case}: {count}")

    threading.Thread(target=run).start()

if __name__ == "__main__":
    main()
```