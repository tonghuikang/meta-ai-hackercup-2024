**Key Findings:**

To solve the problem of counting "mountain" numbers within a given range \([A, B]\) that are divisible by \(M\), we followed these steps:

1. **Understanding Mountain Numbers:**
   - A mountain number has an odd number of digits \(2k + 1\), with no digit being zero.
   - The first \(k + 1\) digits are monotonically non-decreasing.
   - The last \(k + 1\) digits are monotonically non-increasing.
   - The middle digit is unique, meaning it appears exactly once in the entire number.

2. **Generating Mountain Numbers:**
   - For each possible odd length \(n = 2k + 1\), where \(k\) ranges from 0 to 9 (since \(2k+1 \leq 19\) digits for \(B \leq 10^{18}\)):
     - Iterate over possible middle digits \(m\) from 1 to 9.
     - For \(k = 0\), the mountain numbers are simply the single-digit numbers \(1\) to \(9\).
     - For \(k \geq 1\), generate all non-decreasing sequences of length \(k\) for the first part and all non-increasing sequences of length \(k\) for the last part, ensuring that no digit equals the middle digit \(m\).
     - Combine these sequences with the middle digit to form complete mountain numbers.
   - Collect and sort all generated mountain numbers to facilitate efficient range queries.

3. **Processing Test Cases:**
   - For each test case with inputs \(A\), \(B\), and \(M\):
     - Use binary search to identify the subset of precomputed mountain numbers within the range \([A, B]\).
     - Iterate through this subset and count how many numbers are divisible by \(M\).

4. **Efficiency Considerations:**
   - Precomputing all mountain numbers ensures that each test case can be processed quickly by leveraging binary search and simple iteration.
   - The total number of mountain numbers is manageable (significantly less than \(10^6\)), allowing for fast execution even with \(T = 95\) test cases.

**Python Code:**

```python
import sys
import itertools
import bisect

def generate_mountains():
    mountains = []

    # Single-digit mountains (k=0)
    for m in range(1, 10):
        mountains.append(m)

    # For lengths >=3 (k=1 to9)
    for k in range(1, 10):
        for m in range(2, 10):
            max_digit = m - 1
            if max_digit < 1:
                continue  # No valid first or last digits
            # Generate first k digits: non-decreasing, digits 1 to m-1
            first_seqs = list(itertools.combinations_with_replacement(range(1, max_digit + 1), k))
            # Generate last k digits: non-increasing, digits 1 to m-1
            non_decreasing_seqs = list(itertools.combinations_with_replacement(range(1, max_digit + 1), k))
            last_seqs = [tuple(reversed(seq)) for seq in non_decreasing_seqs]
            # Combine first and last sequences with middle digit m
            for first in first_seqs:
                for last in last_seqs:
                    digits = list(first) + [m] + list(last)
                    num = 0
                    for d in digits:
                        num = num * 10 + d
                    mountains.append(num)

    mountains.sort()
    return mountains

def main():
    mountains = generate_mountains()
    input = sys.stdin.read().split()
    T = int(input[0])
    idx = 1
    for tc in range(1, T + 1):
        A = int(input[idx])
        B = int(input[idx + 1])
        M = int(input[idx + 2])
        idx += 3
        # Find left and right indices
        left = bisect.bisect_left(mountains, A)
        right = bisect.bisect_right(mountains, B)
        count = 0
        if M == 1:
            count = right - left
        else:
            subset = mountains[left:right]
            count = sum(1 for num in subset if num % M == 0)
        print(f"Case #{tc}: {count}")

if __name__ == "__main__":
    main()
```