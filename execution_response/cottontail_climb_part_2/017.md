**Key Findings:**

1. **Mountain Number Characteristics:**
   - **Odd-Length**: Mountain numbers must have an odd number of digits, specifically \(2k + 1\) digits for some integer \(k \geq 0\).
   - **Non-Zero Digits**: All digits must be between 1 and 9, inclusive.
   - **Monotonic Sequences**: 
     - The first \(k+1\) digits must be monotonically non-decreasing.
     - The last \(k+1\) digits must be monotonically non-increasing.
   - **Unique Middle Digit**: The middle digit (the \((k+1)\)th digit) must be unique within the number.

2. **Generation Strategy:**
   - **Iterate Over Possible Lengths**: For each odd length from 1 to 19, compute \(k = \frac{l-1}{2}\).
   - **Middle Digit Selection**: For each possible middle digit \(m\) from 1 to 9:
     - **First \(k\) Digits**: Generate all non-decreasing sequences of length \(k\) using digits from 1 to \(m-1\).
     - **Last \(k\) Digits**: Generate all non-increasing sequences of length \(k\) using digits from 1 to \(m-1\).
     - **Combine Sequences**: Concatenate the first \(k\) digits, the middle digit \(m\), and the last \(k\) digits to form a mountain number.
   - **Special Case for Single-Digit Mountains**: When \(k=0\), the mountain numbers are simply digits from 1 to 9.

3. **Efficient Counting:**
   - **Precompute All Mountain Numbers**: Generate and store all possible mountain numbers up to \(10^{19}\).
   - **Sorting for Fast Lookup**: Sort the list of mountain numbers to allow efficient range queries using binary search.
   - **Handling Multiple Test Cases**: For each test case, use binary search to find the relevant subset of mountain numbers within \([A, B]\) and count how many of them are divisible by \(M\).

This approach ensures that despite the large possible range of numbers, the problem remains computationally feasible by leveraging the structured nature of mountain numbers.

```python
import sys
import itertools
import bisect

def generate_non_decreasing_sequences(k, max_digit):
    if k == 0:
        return [()]
    return list(itertools.combinations_with_replacement(range(1, max_digit +1), k))

def generate_non_increasing_sequences(k, max_digit):
    if k == 0:
        return [()]
    sequences = generate_non_decreasing_sequences(k, max_digit)
    return [tuple(reversed(seq)) for seq in sequences]

def generate_all_mountain_numbers():
    mountains = []
    for k in range(0, 10):
        l = 2 * k +1
        for m in range(1, 10):
            if k ==0:
                mountains.append(m)
                continue
            max_digit = m -1
            if max_digit <1:
                continue
            first_sequences = generate_non_decreasing_sequences(k, max_digit)
            last_sequences = generate_non_increasing_sequences(k, max_digit)
            for first_k in first_sequences:
                for last_k in last_sequences:
                    # Combine to form the number
                    num_digits = first_k + (m,) + last_k
                    number = 0
                    for d in num_digits:
                        number = number *10 + d
                    mountains.append(number)
    mountains = sorted(mountains)
    return mountains

def main():
    import sys
    import threading
    def run():
        mountains = generate_all_mountain_numbers()
        T = int(sys.stdin.readline())
        for case in range(1, T+1):
            line = ''
            while line.strip() == '':
                line = sys.stdin.readline()
            A_str, B_str, M_str = line.strip().split()
            A = int(A_str)
            B = int(B_str)
            M = int(M_str)
            # Find the indices
            left = bisect.bisect_left(mountains, A)
            right = bisect.bisect_right(mountains, B)
            count = 0
            for num in mountains[left:right]:
                if num % M ==0:
                    count +=1
            print(f"Case #{case}: {count}")
    threading.Thread(target=run,).start()

if __name__ == "__main__":
    main()
```