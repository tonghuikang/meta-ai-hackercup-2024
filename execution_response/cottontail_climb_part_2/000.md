**Key Findings When Solving the Problem:**

1. **Mountain Number Characteristics:**
   - A mountain number has an odd number of digits, formatted as \(2k + 1\) digits.
   - No digit in the number is zero.
   - The first \(k+1\) digits are monotonically non-decreasing.
   - The last \(k+1\) digits are monotonically non-increasing.
   - The middle digit is the peak and dictates the transition from increasing to decreasing.

2. **Number Length Consideration:**
   - Since mountain numbers must have an odd number of digits, for a given range \([A, B]\), we iterate over all possible odd lengths within this range.
   - For each digit length, we generate all valid mountain numbers.

3. **Generation of Mountain Numbers:**
   - To generate mountain numbers, we:
     - Choose the length \(2k + 1\).
     - Generate the first \(k+1\) digits ensuring they are non-decreasing and non-zero.
     - Ensure the middle digit serves as a peak, meaning the next \(k\) digits must be non-increasing.
   - This approach ensures all generated numbers adhere to the mountain criteria.

4. **Efficient Checking Within Range and Divisibility:**
   - For each generated mountain number, we check if it falls within the range \([A, B]\).
   - If it does, we further check if it's divisible by \(M\).
   - Given the constraints (\(B\) can be up to \(10^{18}\)), it's essential to generate numbers efficiently without enumerating all possibilities.

5. **Optimizations:**
   - Precompute and store all possible mountain numbers up to the maximum possible digit length (19 digits for \(10^{18}\)).
   - Use binary search to quickly count the number of mountains within a specific range \([A, B]\) that are divisible by \(M\).
   - Handle multiple test cases efficiently by reusing precomputed data where possible.

6. **Handling Edge Cases:**
   - Single-digit numbers (\(k=0\)) are considered mountains.
   - Ensure that numbers with leading zeros are excluded since all digits must be non-zero.

**Python Code:**

```python
import sys
import math
from bisect import bisect_left, bisect_right

def generate_mountain_numbers():
    mountains = []
    # Maximum number of digits is 19 (since 10^18 has 19 digits)
    for length in range(1, 20, 2):  # Only odd lengths
        k = length // 2
        # Generate first k+1 digits (non-decreasing, digits 1-9)
        def dfs(prefix, last_digit, depth):
            if depth == k + 1:
                # Now generate the decreasing part
                peak = prefix[-1]
                def dfs_decr(suffix, current_digit, depth_decr):
                    if depth_decr == k:
                        mountains.append(int(prefix + suffix))
                        return
                    for d in range(1, current_digit + 1):
                        dfs_decr(suffix + str(d), d, depth_decr + 1)
                dfs_decr("", peak, 0)
                return
            for d in range(last_digit, 10):
                if d == 0:
                    continue
                dfs(prefix + str(d), d, depth + 1)
        dfs("", 1, 0)
    mountains.sort()
    return mountains

def main():
    mountains = generate_mountain_numbers()
    T = int(sys.stdin.readline())
    for case in range(1, T + 1):
        A_str, B_str, M_str = sys.stdin.readline().split()
        A = int(A_str)
        B = int(B_str)
        M = int(M_str)
        # Find mountains within [A, B]
        left = bisect_left(mountains, A)
        right = bisect_right(mountains, B)
        count = 0
        # Iterate through the relevant mountains and count those divisible by M
        for num in mountains[left:right]:
            if num % M == 0:
                count += 1
        print(f"Case #{case}: {count}")

if __name__ == "__main__":
    main()
```