**Key Findings:**

1. **Mountain Number Characteristics:**
   - **Length:** Must have an odd number of digits, specifically \(2k + 1\) digits for some integer \(k \geq 0\).
   - **Digits:** All digits are non-zero (1-9).
   - **Monotonicity:**
     - The first \(k+1\) digits are monotonically non-decreasing.
     - The last \(k+1\) digits are monotonically non-increasing.
   - **Unique Middle Digit:** The central digit (the \((k+1)\)th digit) appears only once in the entire number.

2. **Solution Approach:**
   - **Precomputation:**
     - Generate all possible mountain numbers up to 19 digits (since \(10^{18}\) has 19 digits).
     - For each possible odd length, iterate through each possible middle digit (1-9).
     - Generate all valid left and right sequences ensuring monotonicity and uniqueness of the middle digit.
   - **Efficient Counting:**
     - Store all generated mountain numbers in a sorted list.
     - For each test case, perform a binary search to identify mountain numbers within the range \([A, B]\).
     - Count how many of these numbers are divisible by \(M\).

3. **Optimizations:**
   - **Recursive Generation with Memoization:** Utilize recursion to generate valid sequences while avoiding redundant computations.
   - **Binary Search:** Leverage the sorted nature of the mountain numbers list to quickly identify relevant numbers for each test case.

4. **Handling Constraints:**
   - Given the constraints (\(B \leq 10^{18}\) and \(M \leq 10^{9}\)), the precomputation ensures that the solution remains efficient even for the upper limits.

Below is the Python implementation encapsulating the above approach:

```python
import sys
import bisect
from itertools import combinations_with_replacement, product

def generate_mountain_numbers():
    mountain_numbers = set()
    for length in range(1, 20, 2):  # odd lengths from 1 to 19
        k = (length - 1) // 2
        for m in range(1, 10):  # middle digit
            # Generate left sequences: length k, non-decreasing, digits 1-9, <=m, not containing m
            left_sequences = []

            def generate_left(pos, last_digit, current):
                if pos == k:
                    left_sequences.append(''.join(map(str, current)))
                    return
                for d in range(last_digit, m+1):
                    if d == m:
                        continue
                    current.append(d)
                    generate_left(pos+1, d, current)
                    current.pop()

            if k == 0:
                left_sequences = ['']
            else:
                generate_left(0, 1, [])

            # Generate right sequences: length k, non-increasing, digits 1-9, <=m, not containing m
            right_sequences = []

            def generate_right(pos, last_digit, current):
                if pos == k:
                    right_sequences.append(''.join(map(str, current)))
                    return
                for d in range(last_digit, 0, -1):
                    if d == m:
                        continue
                    current.append(d)
                    generate_right(pos+1, d, current)
                    current.pop()

            if k == 0:
                right_sequences = ['']
            else:
                generate_right(0, m, [])

            # Combine left, middle, and right
            for left in left_sequences:
                for right in right_sequences:
                    number_str = left + str(m) + right
                    number = int(number_str)
                    mountain_numbers.add(number)
    return sorted(mountain_numbers)

def main():
    mountain_numbers = generate_mountain_numbers()
    T = int(sys.stdin.readline())
    for case in range(1, T+1):
        A_str, B_str, M_str = sys.stdin.readline().strip().split()
        A = int(A_str)
        B = int(B_str)
        M = int(M_str)
        # Find the range in mountain_numbers
        left = bisect.bisect_left(mountain_numbers, A)
        right = bisect.bisect_right(mountain_numbers, B)
        count = 0
        for num in mountain_numbers[left:right]:
            if num % M == 0:
                count +=1
        print(f"Case #{case}: {count}")

if __name__ == "__main__":
    main()
```