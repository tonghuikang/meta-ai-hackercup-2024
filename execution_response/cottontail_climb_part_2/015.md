**Key Findings:**

1. **Understanding Mountain Numbers:**
   - **Definition:** A mountain number has an odd number of digits (2k + 1), all non-zero digits, with the first k+1 digits non-decreasing and the last k+1 digits non-increasing. The middle digit acts as the peak and should be strictly greater than its adjacent digits.
   - **Examples:** Single-digit numbers (1-9) are trivially mountains. Numbers like 121, 1223221 exemplify mountains where the peak is unique and strictly higher than neighboring digits.
   - **Non-Mountain Cases:** Numbers like 12221 or 1232 fail because the peak either isn't unique or doesn't strictly dominate adjacent digits.

2. **Generating Mountain Numbers:**
   - **Approach:** For each possible odd length up to 19 digits, generate all valid non-decreasing sequences for the first half and corresponding non-increasing sequences for the second half, ensuring the peak condition.
   - **Recursive Generation:** Utilize backtracking to create all valid sequences efficiently, considering the constraints for each part of the mountain number.
   - **Performance:** Given the constraints (up to 19 digits), the total number of mountain numbers is manageable (~100,000), allowing precomputation and storage for efficient lookup during test cases.

3. **Handling Test Cases:**
   - **Preprocessing:** Once all mountain numbers are generated and sorted, use binary search (`bisect`) to quickly identify relevant numbers within the range [A, B].
   - **Divisibility Check:** Iterate through the identified sublist and count how many numbers are divisible by M.
   - **Efficiency:** This method ensures that even with multiple test cases and large ranges, the solution remains performant.

4. **Edge Cases:**
   - Ensure that numbers do not include zero.
   - Handle single-digit mountain numbers correctly.
   - Verify that the peak digit is strictly greater than its adjacent digits to satisfy the uniqueness condition.

**Python Code:**

```python
import sys
import bisect

def generate_non_decreasing(length, start, path, results):
    if len(path) == length:
        results.append(path.copy())
        return
    for digit in range(start, 10):
        path.append(digit)
        generate_non_decreasing(length, digit, path, results)
        path.pop()

def generate_non_increasing(length, max_digit, path, results):
    if len(path) == length:
        results.append(path.copy())
        return
    for digit in range(max_digit, 0, -1):
        path.append(digit)
        generate_non_increasing(length, digit, path, results)
        path.pop()

def main():
    import sys

    mountains = []

    for k in range(0, 10):
        length = 2 * k +1
        if length >19:
            continue
        first_part_results = []
        generate_non_decreasing(k +1, 1, [], first_part_results)
        for first_part in first_part_results:
            mid_digit = first_part[-1]
            if k ==0:
                # Single digit mountain
                number = 0
                for d in first_part:
                    number = number *10 + d
                mountains.append(number)
            else:
                if mid_digit <=1:
                    continue
                last_part_results = []
                generate_non_increasing(k, mid_digit -1, [], last_part_results)
                for last_part in last_part_results:
                    number = 0
                    for d in first_part:
                        number = number *10 + d
                    for d in last_part:
                        number = number *10 + d
                    mountains.append(number)

    # Sort the mountains list
    mountains.sort()

    # Read input
    input = sys.stdin.read().split()
    T = int(input[0])
    idx =1
    for test_case in range(1, T+1):
        A = int(input[idx])
        B = int(input[idx +1])
        M = int(input[idx +2])
        idx +=3
        # Find left and right indices
        left = bisect.bisect_left(mountains, A)
        right = bisect.bisect_right(mountains, B)
        sublist = mountains[left:right]
        count =0
        if M ==1:
            count = len(sublist)
        else:
            for num in sublist:
                if num % M ==0:
                    count +=1
        print(f"Case #{test_case}: {count}")

if __name__ == "__main__":
    main()
```

# Short Answer