**Key Findings:**

1. **Mountain Number Characteristics:**
   - **Odd Number of Digits:** Mountain numbers have \(2k + 1\) digits for some integer \(k \geq 0\).
   - **Non-Zero Digits:** All digits in the number are non-zero.
   - **Monotonic Sequences:**
     - The first \(k + 1\) digits are monotonically non-decreasing.
     - The last \(k + 1\) digits are monotonically non-increasing.
   - **Unique Middle Digit:** The middle digit serves as a unique peak, meaning it is greater than its immediate neighbors.

2. **Generating Mountain Numbers:**
   - **Recursive Construction:** Utilize a recursive approach to build mountain numbers digit by digit, ensuring the non-decreasing and non-increasing properties are maintained.
   - **Digit Constraints:** Since digits range from 1 to 9, zero is excluded to satisfy the non-zero digit condition.

3. **Handling Large Ranges Efficiently:**
   - **Preprocessing:** Generate all possible mountain numbers up to 19 digits (as \(10^{18}\) has 18 digits) and store them in a sorted list.
   - **Binary Search:** For each test case, use binary search to quickly identify mountain numbers within the range \([A, B]\).
   - **Divisibility Check:** Iterate through the identified subset and count how many are divisible by \(M\).

4. **Optimization Considerations:**
   - **Memoization:** Cache intermediate results during mountain number generation to avoid redundant computations.
   - **Pruning:** Early terminate recursive calls that cannot possibly lead to valid mountain numbers, enhancing efficiency.

---

```python
import sys
import bisect

def generate_mountain_numbers():
    mountains = []

    def backtrack(prefix, length, k, is_increasing, last_digit):
        if len(prefix) == length:
            if k > 0:
                # Check the peak uniqueness
                peak = prefix[k]
                if prefix[k-1] < peak and prefix[k] > prefix[k+1]:
                    number = int(''.join(map(str, prefix)))
                    mountains.append(number)
            else:
                # Single digit, always a mountain
                number = int(''.join(map(str, prefix)))
                mountains.append(number)
            return

        if len(prefix) < k +1:
            # Build the increasing part
            for d in range(last_digit, 10):
                if d == 0:
                    continue
                prefix.append(d)
                backtrack(prefix, length, k, True, d)
                prefix.pop()
        else:
            # Build the decreasing part
            for d in range(1, prefix[k] +1):
                prefix.append(d)
                backtrack(prefix, length, k, False, d)
                prefix.pop()

    # Generate for different k
    for k in range(0, 9):
        length = 2 * k +1
        if length ==1:
            for d in range(1,10):
                mountains.append(d)
            continue
        backtrack([], length, k, True, 1)
    mountains = sorted(set(mountains))
    return mountains

def main():
    mountains = generate_mountain_numbers()
    T = int(sys.stdin.readline())
    for case in range(1, T+1):
        A, B, M = map(int, sys.stdin.readline().split())
        left = bisect.bisect_left(mountains, A)
        right = bisect.bisect_right(mountains, B)
        count = 0
        for num in mountains[left:right]:
            if num % M ==0:
                count +=1
        print(f"Case #{case}: {count}")

if __name__ == "__main__":
    main()
```