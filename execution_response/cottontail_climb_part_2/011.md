**Key Findings:**

1. **Mountain Number Characteristics**:
   - **Length**: Must be an odd number \(2k + 1\) digits.
   - **Digits**: No digit is zero.
   - **Monotonicity**:
     - The first \(k+1\) digits are monotonically non-decreasing.
     - The last \(k+1\) digits are monotonically non-increasing.
   - **Uniqueness**: The middle digit is unique.

2. **Range and Constraints**:
   - The range \([A, B]\) can go up to \(10^{18}\), but since mountain numbers have a specific structure, their total count remains manageable.
   - Precompute all possible mountain numbers up to 19 digits (since \(10^{18}\) has 19 digits).

3. **Divisibility Check**:
   - After generating all possible mountain numbers, filter them based on the given range \([A, B]\) and check for divisibility by \(M\).

4. **Optimization**:
   - Precompute and store all mountain numbers in a sorted list to efficiently handle multiple test cases.
   - Utilize binary search to find the relevant range within \([A, B]\) for each test case.

```python
import sys
import bisect

def generate_mountain_numbers():
    mountains = []

    def build_mountain(length, current_num, pos, increasing):
        if pos == length:
            mountains.append(int(current_num))
            return
        if pos == 0:
            for d in '123456789':
                build_mountain(length, current_num + d, pos + 1, True)
        else:
            if pos < (length // 2) + 1:
                # Increasing part
                last_digit = current_num[-1]
                for d in range(int(last_digit), 10):
                    if d == 0:
                        continue
                    build_mountain(length, current_num + str(d), pos + 1, True)
            else:
                # Decreasing part
                last_digit = current_num[-1]
                for d in range(int(last_digit), 0, -1):
                    build_mountain(length, current_num + str(d), pos + 1, False)

    for k in range(0, 10):  # because 2*9+1=19
        length = 2 * k + 1
        build_mountain(length, '', 0, True)

    return sorted(mountains)

def main():
    mountains = generate_mountain_numbers()
    input = sys.stdin.read().split()
    T = int(input[0])
    idx = 1
    for tc in range(1, T + 1):
        A = int(input[idx])
        B = int(input[idx + 1])
        M = int(input[idx + 2])
        idx += 3
        # Find mountains in [A, B]
        left = bisect.bisect_left(mountains, A)
        right = bisect.bisect_right(mountains, B)
        count = 0
        for num in mountains[left:right]:
            if num % M == 0:
                count += 1
        print(f"Case #{tc}: {count}")

if __name__ == "__main__":
    main()
```