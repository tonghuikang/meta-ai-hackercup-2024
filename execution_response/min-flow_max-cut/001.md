To solve this problem efficiently, we need to develop an algorithm that operates in linear time per test case, considering the potentially large input sizes (up to 200,000 nodes per case and a total of 5,000,000 nodes across all cases). 

Given that we need to compute \(F(S, K)\) for all \(S\) from \(1\) to \(N\) and \(K\) from \(1\) to \(M\), we're being asked to find the minimal guaranteed sum of treasures we can collect, under the constraint of the worst possible downstream path (since we have no control over which path the river takes us on), where we can collect treasures from at most \(K\) islands.

Here are the key observations and strategies that help us reach an efficient solution:

1. **Worst Path Consideration**: Since the rivers flow downstream and we have no control over which path we take, we need to consider the worst possible downstream path for collecting treasures. This is the path where the sums of treasures are minimized.

2. **Summation Formula Development**: Instead of keeping track of the minimal sums along each possible path (which isn't feasible due to the potential \(O(N^2)\) complexity), we can derive a formula that allows us to compute the total minimal guaranteed treasure we can collect starting from each node. 

3. **Recursive Relation**:
   - **For Leaf Nodes**: The total sum for a leaf node \(v\) is simply \(A_v \times M\), where \(A_v\) is the treasure at node \(v\).
   - **For Internal Nodes**: We recursively define the total sum over \(K\) for a node \(v\) based on its children:
     \[ \text{total\_sum\_over\_K[}v\text{]} = \text{total\_sum\_over\_K[}u_{\text{worst}}\text{]} + A_v \times (M - \text{len[}u_{\text{worst}}\text{]}) \]
     Here, \(u_{\text{worst}}\) is the child of node \(v\) with the minimal value, which we define via a recursive helper variable \(f[v]\).

4. **Helper Variable**:
   - We introduce \(f[v] = \text{total\_sum\_over\_K[}v\text{]} - A_v \times \text{len[}v\text{]}\), which simplifies the computation and helps us efficiently determine \(u_{\text{worst}}\).
   - This variable aids in minimizing the total sum by selecting the child that contributes least to the sum when adjusted for the treasure at node \(v\).

5. **Linear Time Traversal**: By traversing the nodes in post-order (starting from the leaves upwards), we ensure that for each node, we're already aware of the computed sums and lengths for its children, thus avoiding redundant calculations.

Below is the Python code that implements the above strategy:


```python
import sys
import threading
sys.setrecursionlimit(1 << 25)

def main():
    mod = 998244353
    T = int(sys.stdin.readline())
    for case_num in range(1, T + 1):
        N, M = map(int, sys.stdin.readline().split())
        A = list(map(int, sys.stdin.readline().split()))
        tree = [[] for _ in range(N)]
        for _ in range(N - 1):
            U, V = map(int, sys.stdin.readline().split())
            U -= 1
            V -= 1
            tree[U].append(V)  # Since rivers are unidirectional from U to V
        total_sum_over_K = [0] * N
        len_path = [0] * N
        f = [0] * N
        visited = [False] * N

        def dfs(v):
            visited[v] = True
            A_v = A[v]
            if not tree[v]:  # Leaf node
                len_path[v] = 1
                total_sum_over_K[v] = A_v * M
                f[v] = A_v * (M - 1)
            else:
                u_worst = None
                min_f_u = None
                for u in tree[v]:
                    if not visited[u]:
                        dfs(u)
                    f_u = f[u]
                    if min_f_u is None or f_u < min_f_u:
                        min_f_u = f_u
                        u_worst = u
                len_path[v] = len_path[u_worst] + 1
                total_sum_over_K[v] = total_sum_over_K[u_worst] + A_v * (M - len_path[u_worst])
                f[v] = f[u_worst] - A_v
        # Since the rivers flow downstream from node 1, we need to ensure
        # that all nodes are visited (in case of multiple downstream nodes from the root)
        for i in range(N):
            if not visited[i]:
                dfs(i)
        result = sum(total_sum_over_K) % mod
        print(f'Case #{case_num}: {result}')

threading.Thread(target=main).start()
```

**Explanation of the Code**:

- We define a recursive function `dfs(v)` that computes the necessary variables for each node:
  - For leaf nodes, it initializes `total_sum_over_K[v]`, `len_path[v]`, and `f[v]`.
  - For internal nodes, it finds the child `u_worst` with the minimal `f[u]`.
  - Variables are updated according to the recursive relationships we've defined.
- We ensure that every node is visited, as we might have multiple nodes not connected via downstream rivers (though the problem description implies a connected graph from node 1). The outer for-loop with the `visited` check handles any disconnected nodes, just in case.
- The overall time complexity per test case is \( O(N) \), which is acceptable given the constraints.

This approach ensures we efficiently compute the minimal guaranteed treasure for each starting node and sum them up over all \( S \) and \( K \) as required by the problem.