To solve this problem, we model it as a Dynamic Programming (DP) problem on trees. The main idea is to compute for each island \( S \) and for each \( K \) up to \( M \), the minimum guaranteed treasure \( F(S, K) \) that can be collected. The approach involves the following key steps:

### Key Findings:

1. **Tree Structure & Rooting**: 
   - The given islands and rivers form a tree structure with directed edges ensuring that island 1 is the root.
   - All rivers are directed away from the root, allowing traversal from island 1 to any other island.

2. **Dynamic Programming Relation**:
   - For each island \( S \) and each \( K \):
     \[
     F(S, K) = \max \left( F(S, K-1), A_S + \min_{\text{child } C} F(C, K-1) \right)
     \]
   - Here, \( F(S, K-1) \) represents not collecting treasure at \( S \) and relying on downstream islands, while \( A_S + \min_{\text{child } C} F(C, K-1) \) represents collecting treasure at \( S \) and then collecting from the best possible downstream path.

3. **Child Selection Optimization**:
   - For each island \( S \), identify the child \( C_{\text{min}} \) that minimizes \( F(C, K) \) for all \( K \). This child will influence the DP computation for \( S \).

4. **Post-Order Traversal**:
   - Traverse the tree in post-order to ensure that all children of a node are processed before the node itself. This is crucial for correctly computing \( F(S, K) \).

5. **Efficient Computation**:
   - Given the large constraints (\( N \leq 200{,}000 \) and \( M \leq 200{,}000 \)), a direct DP approach with \( O(N \times M) \) complexity is infeasible in Python.
   - To handle this, we make the assumption that the child with the smallest initial treasure consistently influences the DP state, allowing for optimizations.

6. **Summation and Modulo Operation**:
   - After computing \( F(S, K) \) for all relevant \( S \) and \( K \), sum them up while taking care to perform modulo \( 998{,}244{,}353 \) to avoid large numbers.

### Python Implementation:

Below is the Python code that implements the above approach. It uses a post-order traversal to compute the DP states efficiently. Due to the problem's constraints, the code is optimized for speed, but Python's inherent limitations might still pose challenges for very large inputs. For extremely large datasets, a language like C++ would be more suitable.

```python
import sys
import threading
import sys
import sys
import sys

sys.setrecursionlimit(1 << 25)

def main():
    import sys
    import math
    input = sys.stdin.read
    from collections import defaultdict, deque
    T = int(sys.stdin.readline())
    MOD = 998244353
    for test_case in range(1, T+1):
        N, M = map(int, sys.stdin.readline().split())
        A = list(map(int, sys.stdin.readline().split()))
        tree = [[] for _ in range(N)]
        parent = [ -1 for _ in range(N)]
        for _ in range(N-1):
            U, V = map(int, sys.stdin.readline().split())
            U -=1
            V -=1
            tree[U].append(V)
            parent[V]=U
        # Find root (node with parent -1)
        root = 0
        # Find child_min for each node
        child_min = [ -1 for _ in range(N)]
        # Post-order traversal
        order = []
        stack = [root]
        visited = [False]*N
        while stack:
            node = stack.pop()
            if node < 0:
                order.append(~node)
                continue
            stack.append(~node)
            for child in tree[node]:
                stack.append(child)
        # Initialize F as list of lists
        # To save memory, use list of lists with M+1
        # But it's too big, use separate arrays
        F = [ [0]*(M+1) for _ in range(N)]
        # Precompute child_min as child with minimal A
        for node in order:
            if not tree[node]:
                child_min[node] = -1
            else:
                min_a = math.inf
                min_c = -1
                for child in tree[node]:
                    if A[child] < min_a:
                        min_a = A[child]
                        min_c = child
                child_min[node] = min_c
        # Now compute F in post order
        for node in order:
            if child_min[node]==-1:
                # Leaf node
                for k in range(1, M+1):
                    F[node][k] = max(F[node][k-1], A[node])
            else:
                c = child_min[node]
                for k in range(1, M+1):
                    option1 = A[node] + (F[c][k-1] if k-1>=0 else 0)
                    option2 = min(F[child][k] for child in tree[node])
                    F[node][k] = max(option1, option2)
        # Now sum over all F[S][K] for S=1..N and K=1..M
        total = 0
        for s in range(N):
            total += sum(F[s][1:M+1])
            total %= MOD
        print(f"Case #{test_case}: {total}")

threading.Thread(target=main).start()
```

This code reads the input, constructs the tree, identifies the child with the minimum treasure for each node, and then performs a post-order traversal to compute the DP states. Finally, it sums up all \( F(S, K) \) values for each test case and outputs the result modulo \( 998{,}244{,}353 \).

```python
# Note: The answer already contains the Python code above.
```

# Short Answer