**Key Findings:**

1. **Problem Understanding**: We need to determine the K-th smallest score of valid ordered hops between burrows owned by different bunnies on an \( R \times C \) grid. A valid hop must be between two cells owned by different bunnies, and the hop's score is calculated as the maximum of the row and column differences between the two cells.

2. **Constraints Analysis**: Given the large grid size (\( R, C \leq 800 \)) and up to 50 test cases, a brute-force approach (which would involve checking all possible ordered pairs) is computationally infeasible due to the high time complexity.

3. **Efficient Approach**:
   - **Binary Search**: Utilize binary search on the possible score values to find the smallest score \( s \) such that the number of valid hops with scores less than or equal to \( s \) is at least \( K \).
   - **Counting Valid Hops**:
     - **Total Hops (\( N_{\text{total}} \))**: Calculate the total number of ordered pairs with a maximum distance \( \leq s \) using combinatorial formulas.
     - **Same Owner Hops (\( N_{\text{same}} \))**: For each bunny, count the number of ordered pairs of cells it owns that are within the score \( s \). This is done efficiently by sorting the cells and using a sliding window technique with binary search.
     - **Valid Hops (\( N_{\text{valid}} \))**: Subtract the same owner hops from the total hops to obtain the number of valid hops with different owners.
  
4. **Implementation Details**:
   - **Optimized Input Parsing**: Given the large input size, utilize fast input methods in Python to handle the data efficiently.
   - **Per Bunny Processing**: For counting same owner hops, process each bunny individually, leveraging sorted lists and binary searches to minimize computational overhead.
   - **Edge Cases Handling**: Ensure that cases with minimal or maximal scores are correctly handled to avoid off-by-one errors.

The following Python code implements this approach efficiently:

```python
import sys
import threading
from bisect import bisect_left, bisect_right

def main():
    import sys

    import sys

    def readints():
        return list(map(int, sys.stdin.read().split()))

    data = readints()
    ptr = 0
    T = data[ptr]
    ptr +=1
    for test_case in range(1, T+1):
        R = data[ptr]
        C = data[ptr+1]
        K = data[ptr+2]
        ptr +=3
        grid = []
        for _ in range(R):
            row = data[ptr:ptr+C]
            grid.append(row)
            ptr += C
        # Build bunny to cells mapping
        bunny_map = {}
        for i in range(R):
            for j in range(C):
                b = grid[i][j]
                if b not in bunny_map:
                    bunny_map[b] = []
                bunny_map[b].append( (i+1, j+1) )  # 1-indexed
        # Binary search on s
        low = 0
        high = max(R, C)
        answer = high
        while low <= high:
            mid = (low + high) //2
            # Compute N_total
            term1 = R*(2*mid +1) - mid*(mid +1)
            term2 = C*(2*mid +1) - mid*(mid +1)
            N_total = term1 * term2 - R*C
            # Compute N_same
            N_same =0
            for cells in bunny_map.values():
                m = len(cells)
                if m <2:
                    continue
                sorted_cells = sorted(cells, key=lambda x: (x[0], x[1]))
                n = m
                count =0
                j_sorted = [cell[1] for cell in sorted_cells]
                left =0
                for right in range(n):
                    i_right, j_right = sorted_cells[right]
                    while left <= right and i_right - sorted_cells[left][0] > mid:
                        left +=1
                    # Now, cells[left..right] have i within s
                    # Find j within [j_right -s, j_right +s]
                    low_j = j_right - mid
                    high_j_val = j_right + mid
                    l_idx = bisect_left(j_sorted, low_j, left, right+1)
                    r_idx = bisect_right(j_sorted, high_j_val, left, right+1)
                    count += (r_idx - l_idx) -1  # exclude self
                N_same += count *2  # ordered pairs
            # Compute N_valid
            N_valid = N_total - N_same
            if N_valid >= K:
                answer = mid
                high = mid -1
            else:
                low = mid +1
        print(f"Case #{test_case}: {answer}")

threading.Thread(target=main).start()
```