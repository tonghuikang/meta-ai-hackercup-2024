To solve this problem efficiently, we need a way to simulate the movement of the stones without stepping through each individual position, as the constraints on \(N\) are large.

**Key Observations:**

1. **At any given time, there is at most one moving stone.**

2. **Collisions occur only at positions where a stationary stone exists.**

3. **We need to keep track of the positions of stationary stones to handle collisions when a moving stone reaches one of these positions.**

4. **When a collision occurs:**
   - The moving stone stops at the collision position.
   - The stationary stone becomes the new moving stone with the remaining energy.
   - The process continues until all stones are stationary.

**Efficient Simulation Strategy:**

We simulate the stones by tracking the positions of stationary stones and efficiently computing the next collision point using a sorted data structure (e.g., a `list` with binary search via `bisect` module). This allows us to jump directly to the next collision point or the final position without stepping through each unit position.

**Algorithm Steps:**

- **Initialize:**
  - A sorted list (`stationary_positions`) to maintain the positions of stationary stones.
  - A dictionary (`position_to_stone_index`) to map positions to stone indices.
  - A dictionary (`final_position`) to store the final positions of each stone.

- **Process each stone in the order they are thrown (from 1 to \( N \)):**
  - Start with the moving stone at position 0 with its initial energy.
  - While the moving stone has energy:
    - Use `bisect` to find the next stationary stone ahead.
    - If there's no stationary stone within the remaining energy's distance, move the stone directly to its final position.
    - If there is a stationary stone ahead within the moving stone's remaining energy:
      - Move the moving stone to just before the collision position.
      - Adjust the moving stone's energy accordingly.
      - At the collision position:
        - The moving stone stops, and its final position is recorded.
        - The stationary stone at the collision position becomes the new moving stone with the remaining energy.
        - Update the mapping and sorted list to reflect these changes.
      - Continue the process with the new moving stone.

- **After processing all stones:**
  - For each stone, calculate the distance from its final position to the goal \( G \).
  - Find the stone(s) closest to \( G \). In case of a tie, choose the stone with the smallest index.

Here is the implementation of the above strategy:

```python
import sys
import threading
import bisect

def main():
    import sys
    import bisect
    sys.setrecursionlimit(1 << 25)
    T = int(sys.stdin.readline())
    for case_num in range(1, T + 1):
        N, G = map(int, sys.stdin.readline().split())
        E_list = []
        for _ in range(N):
            E = int(sys.stdin.readline())
            E_list.append(E)
        stationary_positions = []
        position_to_stone_index = dict()
        final_position = dict()

        for stone_index, energy in enumerate(E_list, start=1):
            moving_stone_index = stone_index
            moving_energy = energy
            moving_position = 0
            while moving_energy > 0:
                # Find the next collision position
                idx = bisect.bisect_right(stationary_positions, moving_position)
                if idx == len(stationary_positions):
                    # No stationary stones ahead
                    moving_position += moving_energy
                    moving_energy = 0
                    # Record final position
                    final_position[moving_stone_index] = moving_position
                    # Add to stationary stones
                    bisect.insort(stationary_positions, moving_position)
                    position_to_stone_index[moving_position] = moving_stone_index
                    break
                else:
                    next_stationary_pos = stationary_positions[idx]
                    distance_to_next_stationary = next_stationary_pos - moving_position - 1
                    if moving_energy <= distance_to_next_stationary:
                        moving_position += moving_energy
                        moving_energy = 0
                        # Record final position
                        final_position[moving_stone_index] = moving_position
                        # Add to stationary stones
                        bisect.insort(stationary_positions, moving_position)
                        position_to_stone_index[moving_position] = moving_stone_index
                        break
                    else:
                        # Move to just before the collision
                        moving_position += distance_to_next_stationary + 1
                        moving_energy -= distance_to_next_stationary + 1
                        # Collision happens at moving_position
                        # Record final position of moving stone
                        final_position[moving_stone_index] = moving_position
                        # Add moving stone to stationary stones
                        bisect.insort(stationary_positions, moving_position)
                        position_to_stone_index[moving_position] = moving_stone_index
                        # The stationary stone becomes moving
                        stationary_stone_index = position_to_stone_index.pop(moving_position)
                        # Remove from stationary positions
                        stationary_positions.pop(idx)  # Remove the stationary stone
                        # Set the new moving stone index
                        moving_stone_index = stationary_stone_index
                        # moving_position remains the same
                        # Continue the loop with updated moving_stone_index and moving_energy
                        continue
        # After processing all stones, compute distances to G
        min_distance = None
        min_stone_index = None
        for stone_index in range(1, N +1):
            position = final_position[stone_index]
            distance = abs(position - G)
            if min_distance is None or distance < min_distance or \
                (distance == min_distance and stone_index < min_stone_index):
                min_distance = distance
                min_stone_index = stone_index
        print(f"Case #{case_num}: {min_stone_index} {min_distance}")
        
threading.Thread(target=main).start()
```