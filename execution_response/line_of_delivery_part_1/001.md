**Key Findings:**

1. **Understanding the Collision Mechanism:**
   - When a stone is thrown, it moves towards its target position \( E_i \).
   - If it encounters a stationary stone at position \( P \leq E_i \), it stops at \( P \) and transfers its remaining energy \( E_i - P \) to the stationary stone at \( P \). This may cause a chain reaction where the stationary stone moves further if it receives residual energy.

2. **Processing Order:**
   - Stones must be processed in the order they are thrown since the sequence affects collision outcomes.
   - To efficiently handle collisions and energy transfers, it's essential to maintain the positions of stationary stones in a sorted structure to quickly identify potential collision points.

3. **Efficient Data Structures:**
   - Utilize a **sorted list** to keep track of the final positions of stones. This allows for efficient binary search operations to find the nearest collision point for each incoming stone.
   - Use the `bisect` module in Python for binary search operations to maintain and query the sorted list.

4. **Handling Residual Energy and Chain Reactions:**
   - When a collision occurs, the residual energy is transferred to the stationary stone, which might trigger further collisions.
   - Implement a loop to handle these chain reactions until all stones are stationary.

5. **Determining the Closest Stone to the Goal:**
   - After all stones have been processed and their final positions determined, iterate through the stones to find which one is closest to the goal \( G \).
   - In case of a tie, select the stone with the lower index.

6. **Optimizing for Large Inputs:**
   - Given the large constraints (\( N \) up to 300,000 and total \( N \) across test cases up to 2,000,000), it's crucial to ensure that all operations, especially within loops, are optimized for performance.
   - Avoid unnecessary computations and leverage efficient searching and insertion methods provided by the `bisect` module.

**Python Code:**

```python
import sys
import bisect

def main():
    import sys
    import threading

    def solve():
        import sys

        T = int(sys.stdin.readline())
        for test_case in range(1, T + 1):
            N, G = map(int, sys.stdin.readline().split())
            E = []
            for i in range(N):
                E.append((int(sys.stdin.readline()), i + 1))  # (energy, index)

            # Sort stones in the order they are thrown
            # We need to process them sequentially, handling collisions
            # We'll maintain a sorted list of stationary stone positions
            # For each stone, find if there's a stationary stone in its path
            # If yes, transfer residual energy

            # Initialize list of stationary stones positions
            stationary_positions = []
            pos_to_index = dict()  # position to stone index
            stone_final_pos = dict()

            for energy, idx in E:
                # Use bisect to find the first stationary stone position <= energy
                # Since moving from 0 to energy, we need the rightmost stationary stone <= energy
                # bisect_right returns insertion point, so position to check is insertion point -1
                insert_pos = bisect.bisect_right(stationary_positions, energy)
                if insert_pos == 0:
                    # No collision, stone reaches its full energy position
                    final_pos = energy
                    stone_final_pos[idx] = final_pos
                    # Insert into stationary_positions
                    bisect.insort(stationary_positions, final_pos)
                    pos_to_index[final_pos] = idx
                else:
                    # Collision occurs at position stationary_positions[insert_pos -1]
                    collision_pos = stationary_positions[insert_pos -1]
                    residual_energy = energy - collision_pos
                    # The stone at collision_pos is now receiving residual_energy
                    # Its new energy becomes old energy + residual_energy
                    target_idx = pos_to_index[collision_pos]
                    new_energy = residual_energy + collision_pos  # since energy = final_pos
                    # Remove the old position
                    del pos_to_index[collision_pos]
                    stationary_positions.pop(insert_pos -1)
                    # Now, determine the new final position for the target stone
                    # It tries to reach new_energy, but may collide further
                    # This might cause a chain reaction
                    current_energy = new_energy
                    current_idx = target_idx
                    while True:
                        insert_pos_new = bisect.bisect_right(stationary_positions, current_energy)
                        if insert_pos_new == 0:
                            # No further collision
                            final_pos_new = current_energy
                            stone_final_pos[current_idx] = final_pos_new
                            bisect.insort(stationary_positions, final_pos_new)
                            pos_to_index[final_pos_new] = current_idx
                            break
                        else:
                            collision_pos_new = stationary_positions[insert_pos_new -1]
                            residual_energy_new = current_energy - collision_pos_new
                            # Update the target stone
                            target_idx_new = pos_to_index[collision_pos_new]
                            new_energy_new = residual_energy_new + collision_pos_new
                            # Remove the old position
                            del pos_to_index[collision_pos_new]
                            stationary_positions.pop(insert_pos_new -1)
                            # Update current stone to target_idx_new
                            current_energy = new_energy_new
                            current_idx = target_idx_new

            # Now, find the stone closest to G
            min_dist = None
            min_idx = None
            for idx, pos in stone_final_pos.items():
                dist = abs(pos - G)
                if min_dist is None or dist < min_dist or (dist == min_dist and idx < min_idx):
                    min_dist = dist
                    min_idx = idx

            print(f"Case #{test_case}: {min_idx} {min_dist}")

    threading.Thread(target=solve,).start()

if __name__ == "__main__":
    main()
```