**Key Findings:**

To efficiently determine the final positions of stones and identify the one closest to the goal \( G \), the following insights were crucial:

1. **Sorting by Energy:** 
   - Sort the stones in descending order based on their energy \( E_i \). Higher energy stones have the potential to travel further and thus take priority in occupying their desired positions.

2. **Assigning Final Positions:**
   - Iterate through the sorted list and assign each stone a final position. For a stone, its final position is the minimum of its energy \( E_i \) and one unit less than the last assigned position. This ensures that no two stones occupy the same position and that each stone is as far right as possible without overlapping with previously placed stones.

3. **Handling Edge Cases:**
   - Ensure that no stone is assigned a position less than 1, which could occur if too many high-energy stones are placed.
   - Since all \( E_i \) are unique, this simplifies the assignment process by avoiding multiple stones aiming for the same position.

4. **Calculating Distances:**
   - After assigning final positions, calculate the distance of each stone from the goal \( G \).
   - Identify the stone with the smallest distance to \( G \). In case of a tie, select the stone with the smallest index.

This approach ensures that the problem is solved in linearithmic time, which is efficient given the problem constraints.

```python
import sys
import sys
import sys

def main():
    import sys
    import sys
    from sys import stdin
    import sys

    input = sys.stdin.read
    data = input().split()
    idx = 0
    T = int(data[idx]); idx +=1
    for test_case in range(1, T+1):
        N = int(data[idx]); G = int(data[idx+1]); idx +=2
        stones = []
        for i in range(1, N+1):
            E_i = int(data[idx]); idx +=1
            stones.append( ( -E_i, i, E_i ) )  # sort descending
        stones.sort()
        pos = [0]*(N+1)
        last_pos = 10**9
        for s in stones:
            _, i, E_i = s
            final_pos = min(E_i, last_pos -1)
            if final_pos <1:
                final_pos =1
            pos[i] = final_pos
            last_pos = final_pos
        # Now find the stone with minimum |pos[i]-G|
        min_distance = None
        min_index = None
        for i in range(1, N+1):
            distance = abs(pos[i] - G)
            if min_distance is None or distance < min_distance or (distance == min_distance and i < min_index):
                min_distance = distance
                min_index = i
        print(f"Case #{test_case}: {min_index} {min_distance}")

if __name__ == "__main__":
    main()
```

```python
import sys
import sys
import sys

def main():
    import sys
    import sys
    from sys import stdin
    import sys

    input = sys.stdin.read
    data = input().split()
    idx = 0
    T = int(data[idx]); idx +=1
    for test_case in range(1, T+1):
        N = int(data[idx]); G = int(data[idx+1]); idx +=2
        stones = []
        for i in range(1, N+1):
            E_i = int(data[idx]); idx +=1
            stones.append( ( -E_i, i, E_i ) )  # sort descending
        stones.sort()
        pos = [0]*(N+1)
        last_pos = 10**9
        for s in stones:
            _, i, E_i = s
            final_pos = min(E_i, last_pos -1)
            if final_pos <1:
                final_pos =1
            pos[i] = final_pos
            last_pos = final_pos
        # Now find the stone with minimum |pos[i]-G|
        min_distance = None
        min_index = None
        for i in range(1, N+1):
            distance = abs(pos[i] - G)
            if min_distance is None or distance < min_distance or (distance == min_distance and i < min_index):
                min_distance = distance
                min_index = i
        print(f"Case #{test_case}: {min_index} {min_distance}")

if __name__ == "__main__":
    main()
```