### Key Findings

To determine the minimum constant speed \( S \) that allows Sonic to deliver sandwiches to all stations within their respective delivery windows, we can analyze the constraints for each station:

1. **Arrival Time Constraints**:
   - For each station \( i \), Sonic must arrive within the interval \([A_i, B_i]\) seconds.
   - Since the station is \( i \) miles away, the arrival time is \( \frac{i}{S} \) seconds.

2. **Deriving Speed Constraints**:
   - From the arrival time constraints, we derive two inequalities for each station:
     - \( A_i \leq \frac{i}{S} \Rightarrow S \geq \frac{i}{B_i} \)
     - \( \frac{i}{S} \leq B_i \Rightarrow S \leq \frac{i}{A_i} \) (only if \( A_i > 0 \))

3. **Global Constraints**:
   - The minimum speed \( S \) must satisfy all individual station constraints.
   - Therefore, the overall lower bound for \( S \) is the maximum of \( \frac{i}{B_i} \) across all stations.
   - The overall upper bound for \( S \) is the minimum of \( \frac{i}{A_i} \) across all stations where \( A_i > 0 \).

4. **Feasibility Check**:
   - If the maximum lower bound is less than or equal to the minimum upper bound, a valid speed exists.
   - The optimal (minimum) speed \( S \) is then the maximum lower bound.
   - If no such \( S \) exists (i.e., the lower bound exceeds the upper bound), the answer is \(-1\).

5. **Edge Cases**:
   - When \( A_i = 0 \), there is no upper bound for \( S \) from that station, only a lower bound.
   - All \( B_i > A_i \) ensures that division by zero does not occur.

### Python Code

```python
import sys

def main():
    import sys
    import math
    from sys import stdin
    import sys

    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx]); idx +=1
    for test_case in range(1, T+1):
        N = int(input[idx]); idx +=1
        lower = 0.0
        upper = float('inf')
        for i in range(1, N+1):
            A_i = float(input[idx]); idx +=1
            B_i = float(input[idx]); idx +=1
            S_lower = i / B_i
            if A_i > 0:
                S_upper = i / A_i
                if S_upper < upper:
                    upper = S_upper
            # Update the lower bound
            if S_lower > lower:
                lower = S_lower
        # Check feasibility
        if lower <= upper:
            # Format the output with enough precision
            print(f"Case #{test_case}: {lower}")
        else:
            print(f"Case #{test_case}: -1")

if __name__ == "__main__":
    main()
```