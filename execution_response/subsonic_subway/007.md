**Key Findings:**

1. **Understanding the Constraints:**
   - Sonic needs to reach each station `i` (located `i` miles away) within the time interval `[A_i, B_i]`.
   - The speed `v` (miles per second) must satisfy `A_i ≤ i / v ≤ B_i` for each station.
   - This inequality can be rearranged to `v ≥ i / B_i` and `v ≤ i / A_i` (for `A_i > 0`).

2. **Determining the Feasible Speed Range:**
   - The minimum required speed is the maximum of `i / B_i` across all stations, since Sonic must be fast enough to reach the farthest station within its time window.
   - The maximum allowable speed is the minimum of `i / A_i` across stations where `A_i > 0`, ensuring Sonic doesn't arrive too early.
   - If the minimum required speed exceeds the maximum allowable speed, it's impossible to satisfy all constraints, and the answer is `-1`.

3. **Handling Edge Cases:**
   - Stations with `A_i = 0` do not impose an upper speed limit.
   - All delivery windows must be valid (`A_i < B_i`), as per constraints.

4. **Efficient Computation:**
   - Given the large potential size of `N` (up to 1,000,000 per test case), it's crucial to process inputs efficiently.
   - Using optimized input methods like `sys.stdin` and avoiding unnecessary computations ensures the solution runs within time limits.

**Python Code:**

```python
import sys

def main():
    import sys
    import math

    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx +=1
    for test_case in range(1, T+1):
        N = int(input[idx])
        idx +=1
        max_required_speed = 0.0
        min_allowed_speed = math.inf
        for i in range(1, N+1):
            A_i = int(input[idx])
            B_i = int(input[idx+1])
            idx +=2
            # Compute required speed >= i / B_i
            required_speed = i / B_i
            if required_speed > max_required_speed:
                max_required_speed = required_speed
            # If A_i >0, speed <= i / A_i
            if A_i >0:
                allowed_speed = i / A_i
                if allowed_speed < min_allowed_speed:
                    min_allowed_speed = allowed_speed
        # Now check if max_required_speed <= min_allowed_speed
        # If there are no A_i >0, min_allowed_speed remains inf, so no upper bound
        if min_allowed_speed == math.inf:
            # No upper bound
            answer = max_required_speed
        else:
            if max_required_speed <= min_allowed_speed +1e-12:
                answer = max_required_speed
            else:
                answer = -1
        if answer <0:
            print(f"Case #{test_case}: -1")
        else:
            print(f"Case #{test_case}: {answer}")
            
if __name__ == "__main__":
    main()
```