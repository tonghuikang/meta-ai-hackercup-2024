When solving this problem, the goal is to determine the minimum constant speed \( S \) that Sonic can maintain to deliver sandwiches to all stations within their respective delivery windows.

### Key Findings:

1. **Time to Reach Each Station:**
   - The time \( t_i \) taken to reach station \( i \) is given by \( t_i = \frac{i}{S} \).
   - For each station \( i \), \( t_i \) must lie within the interval \([A_i, B_i]\).

2. **Deriving Speed Constraints:**
   - From the condition \( A_i \leq \frac{i}{S} \leq B_i \), we can rearrange to find the permissible range for \( S \):
     - \( S \geq \frac{i}{B_i} \) (to satisfy \( t_i \leq B_i \))
     - If \( A_i > 0 \), \( S \leq \frac{i}{A_i} \) (to satisfy \( t_i \geq A_i \))
   - **Lower Bound (\( S_{min} \)):** The maximum value of \( \frac{i}{B_i} \) across all stations ensures \( S \) is fast enough to meet the latest delivery window.
   - **Upper Bound (\( S_{max} \)):** The minimum value of \( \frac{i}{A_i} \) (for stations with \( A_i > 0 \)) ensures \( S \) is not too fast, which would make Sonic arrive before the delivery window opens.

3. **Feasibility Check:**
   - If \( S_{min} \leq S_{max} \), then \( S_{min} \) is the minimum feasible speed.
   - If no \( S \) satisfies all constraints (i.e., \( S_{min} > S_{max} \)), output \(-1\).

4. **Handling Edge Cases:**
   - If \( A_i = 0 \) for some stations, there's no upper bound imposed by those stations.
   - Ensure precision in floating-point calculations to meet the required error tolerance.

### Python Implementation:

The following Python code efficiently processes the input, computes the necessary bounds, and determines the minimum feasible speed for each test case.

```python
import sys

def main():
    import sys
    import math

    import sys

    def input():
        return sys.stdin.read()

    data = sys.stdin.read().split()
    idx = 0
    T = int(data[idx]); idx += 1
    for test_case in range(1, T+1):
        N = int(data[idx]); idx +=1
        lower_S = 0.0
        upper_S = float('inf')
        for i in range(1, N+1):
            A_i = int(data[idx]); idx +=1
            B_i = int(data[idx]); idx +=1
            if B_i == 0:
                # Not possible since A_i < B_i and B_i >=0, but safe check
                constraints_possible = False
                break
            si_lower = i / B_i
            if si_lower > lower_S:
                lower_S = si_lower
            if A_i > 0:
                si_upper = i / A_i
                if si_upper < upper_S:
                    upper_S = si_upper
        # After processing all stations
        # Check feasibility
        feasible = True
        if lower_S > upper_S + 1e-12:  # Adding small epsilon to account for floating point
            feasible = False
        if feasible:
            # To meet the required precision, format the speed with enough decimal places
            # But the problem allows any format as long as it's within error
            # So we can print lower_S directly
            print(f"Case #{test_case}: {lower_S}")
        else:
            print(f"Case #{test_case}: -1")

if __name__ == "__main__":
    main()
```