**Key Findings:**

1. **Delivery Time Constraints:** For each station \(i\), Sonic must arrive within the time window \([A_i, B_i]\). This translates to the condition:
   \[
   A_i \leq \frac{i}{s} \leq B_i
   \]
   where \(s\) is Sonic's speed.

2. **Speed Bounds:**
   - **Minimum Speed (\(s_{\text{min}}\)):** To ensure Sonic arrives no earlier than \(A_i\), the speed must satisfy:
     \[
     s \geq \frac{i}{B_i}
     \]
     Thus, \(s_{\text{min}}\) is the maximum of all \(\frac{i}{B_i}\) across all stations.
   
   - **Maximum Speed (\(s_{\text{max}}\)):** To ensure Sonic arrives no later than \(B_i\), the speed must satisfy:
     \[
     s \leq \frac{i}{A_i} \quad \text{(if } A_i > 0\text{)}
     \]
     Thus, \(s_{\text{max}}\) is the minimum of all \(\frac{i}{A_i}\) across stations where \(A_i > 0\). If \(A_i = 0\), there is no upper bound for that station.

3. **Feasibility Check:** For a valid speed to exist:
   \[
   s_{\text{min}} \leq s_{\text{max}}
   \]
   If this condition holds, the minimum possible speed is \(s_{\text{min}}\). Otherwise, it's impossible to satisfy all delivery windows, and the answer is \(-1\).

4. **Edge Cases:**
   - **\(A_i = 0\):** Implicitly, no upper speed limit for that station.
   - **\(B_i = 0\) with \(i \geq 1\):** Impossible to satisfy since it would require an infinite speed.

**Python Code:**

```python
import sys

def main():
    import math
    import sys
    input = sys.stdin.read
    data = input().split()
    idx = 0
    T = int(data[idx]); idx +=1
    for test_case in range(1, T+1):
        N = int(data[idx]); idx +=1
        max_s_min = 0.0
        min_s_max = float('inf')
        impossible = False
        for i in range(1, N+1):
            A_i = int(data[idx]); idx +=1
            B_i = int(data[idx]); idx +=1
            if B_i ==0:
                # Need s >= i /0 , impossible unless i==0
                impossible = True
                # Consume remaining input
                for _ in range(i, N+1):
                    A_skip = data[idx]; idx +=1
                    B_skip = data[idx]; idx +=1
                break
            s_min_candidate = i / B_i
            if A_i >0:
                s_max_candidate = i / A_i
                if s_max_candidate < min_s_max:
                    min_s_max = s_max_candidate
            # else s_max_candidate is +inf, do not change min_s_max
            if s_min_candidate > max_s_min:
                max_s_min = s_min_candidate
        if not impossible and max_s_min <= min_s_max:
            # Format to 10 decimal places to ensure precision
            print(f"Case #{test_case}: {max_s_min:.10f}".rstrip('0').rstrip('.'))
        else:
            print(f"Case #{test_case}: -1")
                

if __name__ == "__main__":
    main()
```