**Key Findings:**

1. **Understanding the Problem:**
   - Sonic needs to deliver sandwiches to `N` stations located at distances `1` to `N` miles.
   - He runs at a constant speed `s` (miles per second) and must reach each station `i` within its delivery window `[A_i, B_i]`.
   - The time to reach station `i` is `t_i = i / s`.

2. **Deriving Constraints:**
   - **Lower Bound on Speed (`s`):** To ensure Sonic arrives by the latest permissible time `B_i`, his speed must satisfy `s >= i / B_i` for all stations.
   - **Upper Bound on Speed (`s`):** To ensure Sonic doesn't arrive too early before `A_i`, for stations where `A_i > 0`, his speed must satisfy `s <= i / A_i`.
   - If `A_i = 0`, there is no upper bound constraint for that station.

3. **Solution Strategy:**
   - **Determine the Minimum Required Speed (`lower_bound`):** This is the maximum value of `i / B_i` across all stations.
   - **Determine the Maximum Allowable Speed (`upper_bound`):** This is the minimum value of `i / A_i` across all stations where `A_i > 0`.
   - **Feasibility Check:** If `lower_bound` â‰¤ `upper_bound`, then the minimum feasible speed is `lower_bound`. Otherwise, it's impossible to satisfy all delivery windows, and the answer is `-1`.

4. **Implementation Considerations:**
   - Efficiently handle large inputs by reading the entire input at once and processing it line by line.
   - Use floating-point arithmetic to handle divisions and comparisons.
   - Ensure output precision meets the problem's requirements (within an absolute or relative error of `10^{-6}`).

**Python Code:**

```python
import sys

def main():
    import sys
    import math

    input = sys.stdin.read().split()
    ptr = 0
    T = int(input[ptr])
    ptr +=1
    for test_case in range(1, T+1):
        N = int(input[ptr])
        ptr +=1
        lower_bound = 0.0
        upper_bound = float('inf')
        for i in range(1, N+1):
            Ai = int(input[ptr])
            Bi = int(input[ptr+1])
            ptr +=2
            s_lb_i = i / Bi
            lower_bound = max(lower_bound, s_lb_i)
            if Ai >0:
                s_ub_i = i / Ai
                upper_bound = min(upper_bound, s_ub_i)
        if lower_bound <= upper_bound:
            # To handle floating precision, format with enough decimals
            # Remove trailing zeros and possible decimal point
            s = lower_bound
            # To ensure minimal representation but enough precision
            s_str = "{0:.10f}".format(s).rstrip('0').rstrip('.')
            print(f"Case #{test_case}: {s_str}")
        else:
            print(f"Case #{test_case}: -1")

if __name__ == "__main__":
    main()
```