**Key Findings:**

To determine the minimum constant speed that Sonic needs to maintain to deliver sandwiches to all stations within their respective delivery windows, we can follow these steps:

1. **Understanding Delivery Constraints:**
   - For each station \( i \) (located \( i \) miles away), Sonic must arrive within the time interval \([A_i, B_i]\) seconds.
   - This translates to two conditions for the speed \( s \) (in miles per second):
     - **Lower Bound:** To ensure Sonic arrives **no later** than \( B_i \) seconds, \( s \geq \frac{i}{B_i} \).
     - **Upper Bound:** To ensure Sonic arrives **no earlier** than \( A_i \) seconds, \( s \leq \frac{i}{A_i} \) (only applicable if \( A_i > 0 \)).

2. **Determining Feasibility:**
   - **Minimum Speed Required:** The highest lower bound across all stations, i.e., \( \text{max}\left(\frac{i}{B_i}\right) \).
   - **Maximum Allowed Speed:** The lowest upper bound across all stations where \( A_i > 0 \), i.e., \( \text{min}\left(\frac{i}{A_i}\right) \).
   - If no station has \( A_i > 0 \), the upper bound is considered infinite.
   - **Feasibility Check:** If the minimum required speed is less than or equal to the maximum allowed speed, a valid speed exists. Otherwise, it's impossible to satisfy all delivery windows.

3. **Algorithm Steps:**
   - Iterate through each station to compute the lower and upper bounds.
   - Keep track of the maximum lower bound and the minimum upper bound.
   - After processing all stations:
     - If the maximum lower bound \( \leq \) minimum upper bound, output the maximum lower bound as the minimum required speed.
     - Otherwise, output `-1` indicating it's impossible to satisfy all delivery windows.

4. **Edge Cases to Consider:**
   - Stations with \( A_i = 0 \) have no upper speed limit.
   - All stations have \( A_i = 0 \), in which case only the lower bounds are relevant.
   - Ensure that division by zero is handled when \( A_i = 0 \).

**Python Code:**

```python
import sys

def main():
    import sys
    import math

    import sys

    import sys

    def input():
        return sys.stdin.read()

    data = input().split()
    idx = 0
    T = int(data[idx])
    idx +=1
    for case in range(1, T+1):
        N = int(data[idx])
        idx +=1
        max_lower = 0.0
        min_upper = float('inf')
        for i in range(1, N+1):
            A_i = int(data[idx])
            B_i = int(data[idx+1])
            idx +=2
            # Compute lower bound
            lower = i / B_i
            if lower > max_lower:
                max_lower = lower
            # Compute upper bound if A_i >0
            if A_i >0:
                upper = i / A_i
                if upper < min_upper:
                    min_upper = upper
        # After all stations
        if min_upper < float('inf'):
            if max_lower <= min_upper +1e-12:
                result = max_lower
            else:
                result = -1
        else:
            result = max_lower
        if result < -0.5:
            print(f"Case #{case}: -1")
        else:
            print(f"Case #{case}: {result:.10f}".rstrip('0').rstrip('.') if '.' in f"{result:.10f}" else f"{result:.10f}")

if __name__ == "__main__":
    main()
```

**Explanation of the Code:**

1. **Input Handling:**
   - The entire input is read at once and split into a list for efficient access.
   - An index `idx` is used to keep track of the current position in the input list.

2. **Processing Each Test Case:**
   - For each test case, read the number of stations \( N \).
   - Initialize `max_lower` to keep track of the maximum lower bound and `min_upper` for the minimum upper bound.
   - Iterate through each station:
     - Read \( A_i \) and \( B_i \).
     - Calculate the lower bound \( \frac{i}{B_i} \) and update `max_lower` if necessary.
     - If \( A_i > 0 \), calculate the upper bound \( \frac{i}{A_i} \) and update `min_upper` if necessary.
   
3. **Determining the Result:**
   - After processing all stations, check if a valid speed exists by comparing `max_lower` and `min_upper`.
   - If `min_upper` is still infinity (i.e., all \( A_i = 0 \)), the minimum required speed is `max_lower`.
   - If `max_lower` is less than or equal to `min_upper`, output `max_lower`.
   - Otherwise, output `-1`.

4. **Output Formatting:**
   - The result is printed with up to 10 decimal places.
   - Trailing zeros and decimal points are trimmed for cleaner output, ensuring adherence to the problem's precision requirements.

5. **Edge Case Handling:**
   - The code handles scenarios where \( A_i = 0 \) by not updating `min_upper`.
   - It ensures that division by zero is avoided by only calculating upper bounds when \( A_i > 0 \).

This approach ensures that the solution is efficient and can handle large inputs within the given constraints.

```
# Note: This code is meant to be run as a standalone script. It reads from standard input and writes to standard output.
```