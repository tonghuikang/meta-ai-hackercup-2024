**Key Findings:**

1. **Arrival Time Constraints:** For each station `i`, Sonic must arrive within the time window `[A_i, B_i]`. Since the distance to station `i` is `i` miles and Sonic runs at a constant speed `s`, the arrival time is `t = i / s`. Therefore, the constraint becomes:
   
   \[
   A_i \leq \frac{i}{s} \leq B_i
   \]

2. **Speed Boundaries:**
   - **Lower Bound:** To satisfy the upper time limit `B_i`, the speed must be at least `s >= i / B_i` for each station.
   - **Upper Bound:** To satisfy the lower time limit `A_i` (when `A_i > 0`), the speed must be at most `s <= i / A_i`. If `A_i = 0`, there's no upper bound from that station.

3. **Feasibility Check:** 
   - Calculate the maximum of all `i / B_i` values to determine the minimum required speed (`min_speed`).
   - Calculate the minimum of all `i / A_i` values (considering only stations where `A_i > 0`) to determine the maximum allowable speed (`max_speed`).
   - If `min_speed` exceeds `max_speed`, it's impossible to satisfy all constraints, and the output should be `-1`.
   - Otherwise, the minimal constant speed that satisfies all constraints is `min_speed`.

4. **Edge Cases:**
   - If all `A_i` are `0`, there's no upper bound on the speed, and the minimal speed is simply the maximum `i / B_i`.
   - Ensure handling of large inputs efficiently, as `N` can be up to `1,000,000` per test case.

**Python Code:**

```python
import sys

def main():
    import sys
    import math

    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx += 1
    for test_case in range(1, T + 1):
        N = int(input[idx])
        idx += 1
        min_speed = 0.0
        max_speed = math.inf
        for i in range(1, N + 1):
            A_i = float(input[idx])
            B_i = float(input[idx + 1])
            idx += 2
            # Calculate speed lower bound: s >= i / B_i
            if B_i == 0:
                # Impossible to reach if B_i is 0
                min_speed = math.inf
            else:
                min_speed = max(min_speed, i / B_i)
            # Calculate speed upper bound: s <= i / A_i, only if A_i > 0
            if A_i > 0:
                max_speed = min(max_speed, i / A_i)
            # If at any point min_speed > max_speed, no solution
        if min_speed - max_speed > 1e-12:
            result = -1
        else:
            # If min_speed <= max_speed, it is achievable
            # If min_speed is infinite, no solution
            if min_speed == math.inf:
                result = -1
            else:
                result = min_speed
        if result == -1:
            print(f"Case #{test_case}: -1")
        else:
            # Print with up to 10 decimal places to ensure precision
            print(f"Case #{test_case}: {result:.10f}".rstrip('0').rstrip('.'))
            
if __name__ == "__main__":
    main()
```