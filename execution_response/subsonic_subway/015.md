**Key Findings:**

To determine the minimum constant speed \( v \) that Sonic needs to maintain to deliver sandwiches to all stations within their respective delivery windows, we analyze the constraints for each station:

1. **Delivery Time Constraint:**
   - For station \( i \) located \( i \) miles away, the delivery time \( t_i \) is given by \( t_i = \frac{i}{v} \).
   - This delivery time must satisfy \( A_i \leq t_i \leq B_i \), which can be rewritten as:
     \[
     \frac{i}{B_i} \leq v \leq \frac{i}{A_i} \quad (\text{if } A_i > 0)
     \]
     If \( A_i = 0 \), there's no upper bound on \( v \), so it only requires:
     \[
     v \geq \frac{i}{B_i}
     \]

2. **Global Constraints:**
   - To satisfy all stations simultaneously:
     - The minimum required speed \( v_{\text{min}} \) is the maximum of all \( \frac{i}{B_i} \) values.
     - The maximum allowed speed \( v_{\text{max}} \) is the minimum of all \( \frac{i}{A_i} \) values where \( A_i > 0 \).
   
3. **Feasibility Check:**
   - If \( v_{\text{min}} \leq v_{\text{max}} \), then a valid speed exists, and the minimum speed is \( v_{\text{min}} \).
   - Otherwise, it's impossible to satisfy all delivery windows, and the output should be `-1`.

The following Python code implements this logic efficiently, considering the large constraints on \( N \):

```python
import sys

def main():
    import sys
    import math

    T = int(sys.stdin.readline())
    for test_case in range(1, T+1):
        N_line = ''
        while N_line.strip() == '':
            N_line = sys.stdin.readline()
        N = int(N_line)
        max_v_min = 0.0
        v_max_candidates = []
        impossible = False
        for i in range(1, N+1):
            line = ''
            while line.strip() == '':
                line = sys.stdin.readline()
            A_i, B_i = map(int, line.strip().split())
            if B_i == 0:
                # B_i is zero, delivery time must be zero, which implies v = inf unless i=0
                if i !=0:
                    impossible = True
                    continue
            # v >= i / B_i
            if B_i == 0:
                # If B_i is 0, only possible if i ==0
                if i !=0:
                    impossible = True
            else:
                v_min = i / B_i
                if v_min > max_v_min:
                    max_v_min = v_min
            if A_i > 0:
                v_max = i / A_i
                v_max_candidates.append(v_max)
        if impossible:
            print(f"Case #{test_case}: -1")
            continue
        if v_max_candidates:
            min_v_max = min(v_max_candidates)
            if max_v_min > min_v_max + 1e-12:
                print(f"Case #{test_case}: -1")
                continue
        # Now, need to ensure that max_v_min <= min_v_max (if any)
        # The minimal speed that satisfies all is max_v_min
        print(f"Case #{test_case}: {max_v_min if not v_max_candidates or max_v_min <= min(v_max_candidates) else -1}")
        
if __name__ == "__main__":
    main()
```