**Key Findings:**

1. **Constraint Interpretation:**
   - For each station \(i\), Sonic needs to arrive within the time window \([A_i, B_i]\) seconds. Given the distance \(i\) miles, the arrival time is \( t = \frac{i}{s} \), where \(s\) is Sonic's constant speed.
   - This translates to the inequalities:
     \[
     A_i \leq \frac{i}{s} \leq B_i \implies s \geq \frac{i}{B_i} \quad \text{and} \quad s \leq \frac{i}{A_i} \quad (\text{if } A_i > 0)
     \]
   
2. **Determining Feasibility:**
   - The minimum possible speed \(s_{\text{min}}\) must be the maximum of all \(\frac{i}{B_i}\) to satisfy all lower bounds.
   - The maximum allowable speed \(s_{\text{max}}\) is the minimum of all \(\frac{i}{A_i}\) (only considering \(A_i > 0\)).
   - If \(s_{\text{min}} \leq s_{\text{max}}\), a feasible speed exists, and the minimum required speed is \(s_{\text{min}}\). Otherwise, it's impossible to satisfy all delivery windows, and the output should be \(-1\).

3. **Handling Edge Cases:**
   - When \(A_i = 0\), there is no upper speed limit from that station, so it doesn't affect \(s_{\text{max}}\).
   - All divisions must handle floating-point precision to ensure the final speed is accurate within the required error margin.

**Python Code:**

```python
import sys

def solve():
    import sys
    import math

    from sys import stdin
    input = sys.stdin.read
    data = input().split()
    idx = 0
    T = int(data[idx]); idx +=1
    for test_case in range(1, T+1):
        N = int(data[idx]); idx +=1
        s_lower_max = 0.0
        s_upper_min = math.inf
        for i in range(1, N+1):
            A_i = float(data[idx]); idx +=1
            B_i = float(data[idx]); idx +=1
            if B_i == 0:
                # According to constraints, A_i < B_i, so B_i >0
                pass
            s_lower_i = i / B_i
            if s_lower_i > s_lower_max:
                s_lower_max = s_lower_i
            if A_i > 0:
                s_upper_i = i / A_i
                if s_upper_i < s_upper_min:
                    s_upper_min = s_upper_i
            else:
                # A_i =0: no upper limit from this station
                pass
        # After all stations
        if s_lower_max <= s_upper_min:
            # Valid speed exists
            # To handle precision up to 1e-6, format accordingly
            answer = s_lower_max
            print(f"Case #{test_case}: {answer:.10f}".rstrip('0').rstrip('.'))
        else:
            print(f"Case #{test_case}: -1")
```

```python
import sys

def solve():
    import sys
    import math

    from sys import stdin
    input = sys.stdin.read
    data = input().split()
    idx = 0
    T = int(data[idx]); idx +=1
    for test_case in range(1, T+1):
        N = int(data[idx]); idx +=1
        s_lower_max = 0.0
        s_upper_min = math.inf
        for i in range(1, N+1):
            A_i = float(data[idx]); idx +=1
            B_i = float(data[idx]); idx +=1
            if B_i == 0:
                # According to constraints, A_i < B_i, so B_i >0
                pass
            s_lower_i = i / B_i
            if s_lower_i > s_lower_max:
                s_lower_max = s_lower_i
            if A_i > 0:
                s_upper_i = i / A_i
                if s_upper_i < s_upper_min:
                    s_upper_min = s_upper_i
            else:
                # A_i =0: no upper limit from this station
                pass
        # After all stations
        if s_lower_max <= s_upper_min:
            # Valid speed exists
            # To handle precision up to 1e-6, format accordingly
            answer = s_lower_max
            print(f"Case #{test_case}: {answer:.10f}".rstrip('0').rstrip('.'))
        else:
            print(f"Case #{test_case}: -1")
```