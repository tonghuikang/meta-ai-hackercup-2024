To solve this problem, the key is to find the minimal constant speed at which Sonic must run to satisfy all the delivery windows.

**Key Findings:**

- For each station `i`, Sonic must arrive at time `t_i = i / v`, where `v` is his constant speed.
- The arrival time at station `i` must be within the delivery window `[A_i, B_i]`, so `A_i ≤ i / v ≤ B_i`.
- This inequality can be rearranged to find the acceptable range for `v` for each station:
  - Lower bound: `v ≥ i / B_i`
  - Upper bound (if `A_i > 0`): `v ≤ i / A_i`
  - If `A_i = 0`, there is no upper bound contributed by that station.
- The overall acceptable speed `v` must satisfy:
  - `v ≥ max (i / B_i)` over all stations
  - `v ≤ min (i / A_i)` over all stations where `A_i > 0`
- If the maximum of the lower bounds `v_min` is less than or equal to the minimum of the upper bounds `v_max`, then a solution exists, and the minimal acceptable speed is `v_min`.
- If `v_min > v_max`, there is no acceptable constant speed, and we output `-1`.

Below is the Python code implementing this solution:

```python
import sys

import threading

def main():
    import math
    T = int(sys.stdin.readline())
    for case_num in range(1, T + 1):
        N = int(sys.stdin.readline())
        v_min = 0.0
        v_max = float('inf')
        for i in range(1, N +1):
            A_i_str, B_i_str = sys.stdin.readline().split()
            A_i = int(A_i_str)
            B_i = int(B_i_str)
            v_min_candidate = i / B_i
            v_min = max(v_min, v_min_candidate)
            if A_i > 0:
                v_max_candidate = i / A_i
                v_max = min(v_max, v_max_candidate)
            # No update to v_max when A_i == 0
        if v_min <= v_max + 1e-9:  # Adding a small epsilon to account for floating point errors
            # Ensure output within acceptable precision
            print(f"Case #{case_num}: {v_min:.10f}")
        else:
            print(f"Case #{case_num}: -1")


threading.Thread(target=main).start()
```