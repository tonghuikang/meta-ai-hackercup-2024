To solve this problem, we can interpret Sonic's delivery timeline constraints in terms of intervals for the reciprocal of his speed, \( \frac{1}{v} \). Here's how:

1. **Delivery Time Constraints**:
   - For each station \( i \), Sonic must arrive within the time window \( [A_i, B_i] \).
   - Since station \( i \) is \( i \) miles away and he's running at a constant speed \( v \), his arrival time at station \( i \) is \( \frac{i}{v} \).

2. **Inequality Transformation**:
   - The inequality \( A_i \leq \frac{i}{v} \leq B_i \) can be rearranged to \( \frac{A_i}{i} \leq \frac{1}{v} \leq \frac{B_i}{i} \).
   - This represents an interval \( [\frac{A_i}{i}, \frac{B_i}{i}] \) for \( \frac{1}{v} \).

3. **Interval Intersection**:
   - Sonic must satisfy all \( N \) intervals simultaneously.
   - Therefore, the valid range for \( \frac{1}{v} \) is the intersection of all intervals \( [\frac{A_i}{i}, \frac{B_i}{i}] \).
   - Compute the **maximum** of the lower bounds \( \text{low} = \max \left( \frac{A_i}{i} \right) \) and the **minimum** of the upper bounds \( \text{high} = \min \left( \frac{B_i}{i} \right) \).

4. **Checking Feasibility**:
   - If \( \text{low} > \text{high} \) or \( \text{high} \leq 0 \), the intersection is empty, and it's impossible for Sonic to meet all delivery times at a constant speed. Output `-1` in this case.

5. **Calculating Minimum Speed**:
   - If the intersection is not empty, the minimal constant speed \( v \) is the reciprocal of \( \text{high} \), i.e., \( v = \frac{1}{\text{high}} \).
   - This provides the slowest possible speed within the valid interval, ensuring Sonic conserves as much energy as possible.

6. **Precision Considerations**:
   - Since answers within an absolute or relative error of \( 10^{-6} \) are acceptable, ensure that floating-point calculations maintain sufficient precision.
   - When outputting the result, format the speed with at least seven decimal places.

Below is the Python code implementing the above logic:

```python
import sys

import threading
def main():
    T = int(sys.stdin.readline())
    for case_num in range(1, T+1):
        N = int(sys.stdin.readline())
        low = 0.0
        high = float('inf')
        for i in range(1, N+1):
            Ai_str, Bi_str = sys.stdin.readline().split()
            Ai = int(Ai_str)
            Bi = int(Bi_str)
            Ai_div_i = Ai / i
            Bi_div_i = Bi / i
            if Ai_div_i > Bi_div_i:
                # This interval is invalid; no need to proceed further.
                low = 1.0
                high = 0.0
                break
            low = max(low, Ai_div_i)
            high = min(high, Bi_div_i)
        if low > high or high <= 0.0:
            print(f"Case #{case_num}: -1")
        else:
            v = 1.0 / high
            # Ensure we have enough precision
            print(f"Case #{case_num}: {v:.10f}")
threading.Thread(target=main).start()
```