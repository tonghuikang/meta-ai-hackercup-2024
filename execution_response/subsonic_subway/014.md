**Key Findings:**

To determine the minimal constant speed \( S \) that allows Sonic to deliver sandwiches to all stations within their respective delivery windows, we can analyze the problem as follows:

1. **Delivery Time Calculation:**
   - For each station \( i \), Sonic must reach it within the time interval \([A_i, B_i]\).
   - The time taken to reach station \( i \) at speed \( S \) is \( \frac{i}{S} \) seconds.

2. **Constraints on Speed \( S \):**
   - To satisfy the delivery window for each station:
     - **Lower Bound:** \( S \geq \frac{i}{B_i} \) to ensure Sonic arrives no later than \( B_i \).
     - **Upper Bound:** If \( A_i > 0 \), \( S \leq \frac{i}{A_i} \) to ensure Sonic arrives no earlier than \( A_i \).

3. **Determining Feasibility and Minimal Speed:**
   - Compute the maximum lower bound \( S_{\text{min}} = \max\left(\frac{i}{B_i}\right) \) across all stations.
   - Compute the minimum upper bound \( S_{\text{max}} = \min\left(\frac{i}{A_i}\right) \) across stations where \( A_i > 0 \).
   - **Feasibility Check:**
     - If \( S_{\text{max}} \geq S_{\text{min}} \), a valid speed exists, and the minimal speed \( S \) is \( S_{\text{min}} \).
     - Otherwise, it's impossible to satisfy all delivery windows, and the answer is \(-1\).

4. **Edge Cases:**
   - If all \( A_i = 0 \), there's no upper bound on \( S \), and the minimal feasible speed is simply \( S_{\text{min}} \).
   - Ensure floating-point precision is handled correctly to meet the problem's accuracy requirements.

**Python Code Implementation:**

```python
import sys

def main():
    import sys
    import math

    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx])
    idx +=1
    for tc in range(1, T+1):
        N = int(input[idx])
        idx +=1
        max_S = 0.0
        min_S = float('inf')
        has_A_positive = False
        for i in range(1, N+1):
            A_i = int(input[idx])
            B_i = int(input[idx+1])
            idx +=2
            # Compute i / B_i
            current_max_S = i / B_i
            if current_max_S > max_S:
                max_S = current_max_S
            # If A_i >0, compute i / A_i
            if A_i >0:
                has_A_positive = True
                current_min_S = i / A_i
                if current_min_S < min_S:
                    min_S = current_min_S
        # After all stations
        if has_A_positive:
            if min_S >= max_S - 1e-12:  # Allow a tiny epsilon for floating point
                answer = max_S
            else:
                answer = -1
        else:
            answer = max_S
        if answer <0:
            print(f"Case #{tc}: -1")
        else:
            # To fix floating point representation issues, format with enough decimal places
            print(f"Case #{tc}: {answer:.10f}".rstrip('0').rstrip('.') if '.' in f"{answer:.10f}" else f"{answer:.10f}")
            

if __name__ == "__main__":
    main()
```