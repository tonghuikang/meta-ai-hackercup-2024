When solving this problem, the key observations are:

1. **Speed Constraints**: For each station \(i\), the time \(t_i\) taken to reach it must satisfy \(A_i \leq t_i \leq B_i\). Since \(t_i = \frac{i}{s}\) where \(s\) is the speed, this translates to:
   \[
   A_i \leq \frac{i}{s} \leq B_i \implies \frac{i}{B_i} \leq s \leq \frac{i}{A_i}
   \]
   This means that for each station, there is a lower bound \(\frac{i}{B_i}\) and an upper bound \(\frac{i}{A_i}\) (with \(\frac{i}{A_i}\) treated as infinity if \(A_i = 0\)) on the speed \(s\).

2. **Feasibility Check**: To ensure that Sonic can deliver to all stations, the speed \(s\) must satisfy the condition:
   \[
   \max\left(\frac{i}{B_i}\right) \leq s \leq \min\left(\frac{i}{A_i}\right)
   \]
   If the maximum lower bound exceeds the minimum upper bound, it's impossible to find a valid speed, and the answer should be \(-1\).

3. **Minimum Speed**: If a valid speed exists, the minimum required speed is the maximum of all \(\frac{i}{B_i}\) values.

4. **Efficiency**: Given the large constraints (up to \(5 \times 10^6\) stations across all test cases), the solution needs to process inputs efficiently. This is achieved by reading all inputs at once and processing them using a fast parsing method.

Below is the Python implementation based on these findings:

```python
import sys

def main():
    import sys
    import math

    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx]); idx +=1
    for tc in range(1, T+1):
        N = int(input[idx]); idx +=1
        max_s_lower = 0.0
        min_s_upper = math.inf
        for i in range(1, N+1):
            A = int(input[idx]); idx +=1
            B = int(input[idx]); idx +=1
            s_lower = i / B
            if s_lower > max_s_lower:
                max_s_lower = s_lower
            if A > 0:
                s_upper = i / A
                if s_upper < min_s_upper:
                    min_s_upper = s_upper
        if max_s_lower <= min_s_upper:
            # To avoid floating point issues, format with sufficient decimals
            # Remove trailing zeros
            s = max_s_lower
            s_str = "{0:.10f}".format(s).rstrip('0').rstrip('.')
            print(f"Case #{tc}: {s_str}")
        else:
            print(f"Case #{tc}: -1")

if __name__ == "__main__":
    main()
```

```
python
import sys

def main():
    import sys
    import math

    input = sys.stdin.read().split()
    idx = 0
    T = int(input[idx]); idx +=1
    for tc in range(1, T+1):
        N = int(input[idx]); idx +=1
        max_s_lower = 0.0
        min_s_upper = math.inf
        for i in range(1, N+1):
            A = int(input[idx]); idx +=1
            B = int(input[idx]); idx +=1
            s_lower = i / B
            if s_lower > max_s_lower:
                max_s_lower = s_lower
            if A > 0:
                s_upper = i / A
                if s_upper < min_s_upper:
                    min_s_upper = s_upper
        if max_s_lower <= min_s_upper:
            # To avoid floating point issues, format with sufficient decimals
            # Remove trailing zeros
            s = max_s_lower
            s_str = "{0:.10f}".format(s).rstrip('0').rstrip('.')
            print(f"Case #{tc}: {s_str}")
        else:
            print(f"Case #{tc}: -1")

if __name__ == "__main__":
    main()
```