**Key Findings:**

1. **Validation of Color Groups:**
   - Ensure that no color group has exactly one rabbit. If any color appears only once, it's immediately invalid.

2. **Handling Known Weights:**
   - Verify that all known weights are unique and within the valid range `[1...10,000]`.
   - Group rabbits by their assigned colors, separating known weights from missing ones.

3. **Assigning Missing Weights:**
   - **For Color Groups with Known Weights:**
     - Assign missing weights as close as possible to the existing weights to minimize the range `F(c)`.
     - Attempt to place new weights adjacent to the current minimum or maximum of the group.
     - If no suitable adjacent weight is available, the assignment is invalid.
   - **For Color Groups without Known Weights:**
     - Assign the smallest available consecutive weights to minimize `F(c)`.
     - Ensure that at least two unique weights are assigned to each such group.

4. **Ensuring Uniqueness and Range:**
   - All assigned weights must be unique.
   - Weights must lie within the range `[1...10,000]`.

5. **Efficient Assignment Strategy:**
   - Utilize a sorted list of available weights to efficiently find the closest possible weights for assignment.
   - Prioritize assigning weights to color groups with known weights first, as they have stricter constraints.

6. **Final Validation:**
   - After assignments, ensure all constraints are satisfied.
   - If any step fails (e.g., not enough available weights, inability to assign close weights), output "No".
   - Otherwise, output "Yes" along with the complete list of weights.

**Python Code:**

```python
import sys
import sys
from collections import defaultdict

def main():
    import sys
    import threading

    def solve():
        import sys
        import bisect

        T = int(sys.stdin.readline())
        for test_case in range(1, T+1):
            line = ''
            while line.strip() == '':
                line = sys.stdin.readline()
            N = int(line.strip())
            W = []
            while len(W) < N:
                W += list(map(int, sys.stdin.readline().strip().split()))
            C = []
            while len(C) < N:
                C += list(map(int, sys.stdin.readline().strip().split()))
            # Step 1: Check no color appears exactly once
            color_count = defaultdict(int)
            for c in C:
                color_count[c] +=1
            single_color = False
            for c in color_count:
                if color_count[c]==1:
                    single_color = True
                    break
            if single_color:
                print(f"Case #{test_case}: No")
                continue
            # Step 2: Check known weights uniqueness and range
            used_weights = set()
            invalid = False
            for w in W:
                if w != -1:
                    if w <1 or w >10000:
                        invalid = True
                        break
                    if w in used_weights:
                        invalid = True
                        break
                    used_weights.add(w)
            if invalid:
                print(f"Case #{test_case}: No")
                continue
            # Step 3: Collect per color group
            color_groups = defaultdict(lambda: {'indices':[], 'known_w':[], 'missing_idx':[]})
            for idx in range(N):
                c = C[idx]
                color_groups[c]['indices'].append(idx)
                if W[idx] != -1:
                    color_groups[c]['known_w'].append(W[idx])
                else:
                    color_groups[c]['missing_idx'].append(idx)
            # Step 4: Create available_weights sorted list
            # To make it efficient, use a list and keep it sorted
            available_weights = []
            current = 1
            used = sorted(used_weights)
            u_idx = 0
            for num in range(1,10001):
                if u_idx < len(used) and num == used[u_idx]:
                    u_idx +=1
                    continue
                available_weights.append(num)
            # Step 5: Assign missing weights
            assignment_possible = True
            # To keep track of assignments
            new_W = W.copy()
            # First assign to color groups with known weights
            # Sort color groups with known weights first
            colors_with_known = []
            colors_without_known = []
            for c in color_groups:
                if len(color_groups[c]['known_w']) >0:
                    colors_with_known.append(c)
                else:
                    colors_without_known.append(c)
            # Process colors with known weights
            for c in colors_with_known:
                group = color_groups[c]
                known_w = sorted(group['known_w'])
                min_w = known_w[0]
                max_w = known_w[-1]
                missing = len(group['missing_idx'])
                for _ in range(missing):
                    candidate_low = min_w -1
                    candidate_high = max_w +1
                    assign_low = False
                    assign_high = False
                    if candidate_low >=1 and candidate_low not in used_weights:
                        # Assign low
                        assign_low = True
                    if candidate_high <=10000 and candidate_high not in used_weights:
                        # Assign high
                        assign_high = True
                    if assign_low and (not assign_high or (min_w - candidate_low) <= (candidate_high - max_w)):
                        # Assign low
                        assigned = candidate_low
                        new_W[group['missing_idx'].pop(0)] = assigned
                        used_weights.add(assigned)
                        # Remove from available_weights
                        pos = bisect.bisect_left(available_weights, assigned)
                        if pos < len(available_weights) and available_weights[pos]==assigned:
                            del available_weights[pos]
                        min_w = assigned
                    elif assign_high:
                        # Assign high
                        assigned = candidate_high
                        new_W[group['missing_idx'].pop(0)] = assigned
                        used_weights.add(assigned)
                        # Remove from available_weights
                        pos = bisect.bisect_left(available_weights, assigned)
                        if pos < len(available_weights) and available_weights[pos]==assigned:
                            del available_weights[pos]
                        max_w = assigned
                    else:
                        # Cannot assign
                        assignment_possible = False
                        break
                if not assignment_possible:
                    break
            if not assignment_possible:
                print(f"Case #{test_case}: No")
                continue
            # Then assign to color groups without known weights
            # Assign smallest available weights, trying to keep them consecutive
            # Sort the groups to assign those with larger sizes first
            colors_without_known_sorted = sorted(colors_without_known, key=lambda x: -len(color_groups[x]['missing_idx']))
            for c in colors_without_known_sorted:
                group = color_groups[c]
                missing = len(group['missing_idx'])
                if missing <2:
                    assignment_possible = False
                    break
                # Find a window of 'missing' consecutive available_weights with minimal range
                # For simplicity, assign the first 'missing' available weights
                if len(available_weights) < missing:
                    assignment_possible = False
                    break
                # To minimize range, try to find the smallest possible window
                # Initialize minimum range and starting index
                min_range = 10001
                start_idx = -1
                for i in range(len(available_weights) - missing +1):
                    current_range = available_weights[i + missing -1] - available_weights[i]
                    if current_range < min_range:
                        min_range = current_range
                        start_idx = i
                        if min_range ==0:
                            break
                if start_idx == -1:
                    assignment_possible = False
                    break
                # Assign these weights to the group
                assigned_weights = available_weights[start_idx:start_idx + missing]
                for idx, w in zip(group['missing_idx'], assigned_weights):
                    new_W[idx] = w
                    used_weights.add(w)
                # Remove assigned_weights from available_weights
                del available_weights[start_idx:start_idx + missing]
            if not assignment_possible:
                print(f"Case #{test_case}: No")
                continue
            # After assignment, verify all weights are unique and within range
            valid = True
            final_weights = new_W
            seen = set()
            for w in final_weights:
                if w <1 or w >10000:
                    valid = False
                    break
                if w in seen:
                    valid = False
                    break
                seen.add(w)
            if not valid:
                print(f"Case #{test_case}: No")
                continue
            # Now, verify that the assignment minimizes the sum F(c)
            # Since we assigned as close as possible, it's assumed
            # So, output "Yes" and the assignment
            print(f"Case #{test_case}: Yes")
            print(' '.join(map(str, final_weights)))
    threading.Thread(target=solve).start()

if __name__ == "__main__":
    main()
```