When approaching this problem, several key insights are essential:

1. **Dynamic Programming for Decoding Counts**:
   - We can use dynamic programming (DP) where `dp[i]` represents the number of ways to decode the substring from position `i` to the end.
   - The base case is `dp[n] = 1`, where `n` is the length of the string, indicating that there's one way to decode an empty string.
   - For each position `i`, we consider one-digit and two-digit possibilities, ensuring they represent valid letters (`1` to `26`).

2. **Handling Corrupted Characters (`?`)**:
   - When encountering a `'?'`, we need to consider all possible digit replacements (`'0'` to `'9'`).
   - For each replacement, we evaluate how it affects the DP counts and select digits that contribute to the maximum number of decodings.

3. **Constructing the Lexicographically Kth Largest String**:
   - After determining the maximum number of decodings, we aim to construct the lexicographically Kth largest string.
   - We iterate through each character, and for each `'?'`, try replacing it with digits from `'9'` down to `'0'` to ensure lexicographical order.
   - At each step, we use the DP counts to decide if we should pick a particular digit or skip it based on the remaining value of `K`.

4. **Efficient Implementation**:
   - To handle large strings (up to 100,000 characters) and multiple test cases efficiently, we precompute valid digit combinations and utilize memoization to store intermediate results.
   - Modular arithmetic is used to prevent integer overflow, as required by the problem statement.

Here's the Python code implementing the above approach:

```python
import sys
import sys
import sys
import sys
sys.setrecursionlimit(1 << 25)

MOD = 998244353

def main():
    import sys
    import sys
    T = int(sys.stdin.readline())
    for test_case in range(1, T+1):
        line = sys.stdin.readline().strip()
        if not line:
            line = sys.stdin.readline().strip()
        E, K = line.rsplit(' ', 1)
        K = int(K)
        n = len(E)
        dp = [0]*(n+1)
        dp[n] = 1
        # Precompute valid single and double digits
        for i in range(n-1, -1, -1):
            if E[i] == '?':
                options = [str(d) for d in range(10)]
            else:
                options = [E[i]]
            total = 0
            for c in options:
                if c == '0':
                    continue
                total += dp[i+1]
            # Check for two-digit numbers
            if i+1 < n:
                if E[i] == '?' and E[i+1] == '?':
                    count = 15  # 10 to 26 inclusive
                elif E[i] == '?':
                    if '0' <= E[i+1] <= '9':
                        first = 1
                        second = int(E[i+1])
                        if first *10 + second <=26 and first*10 + second >=10:
                            count =1
                        else:
                            count =0
                    else:
                        count =0
                elif E[i+1] == '?':
                    if E[i] == '1':
                        count =10
                    elif E[i] == '2':
                        count =6
                    else:
                        count =0
                else:
                    num = int(E[i:i+2])
                    count = 1 if 10 <= num <=26 else 0
                total += count * dp[i+2]
            dp[i] = total % MOD
        max_decodings = dp[0]
        # Now, find all uncorrupted strings that achieve dp[0]==max_decodings
        # and find the lex Kth largest
        # To find lex Kth largest, iterate from left to right,
        # at each '?', choose the highest possible digit that keeps dp[i] same,
        # and decrement K accordingly
        result = []
        i = 0
        while i < n:
            if E[i] != '?':
                digit = E[i]
                result.append(digit)
                i +=1
                continue
            # Try digits from '9' to '0'
            for d in range(9, -1, -1):
                c = str(d)
                # Check if c is a valid single digit (non-zero)
                if c == '0':
                    single_valid = False
                else:
                    single_valid = True
                # Calculate ways if we choose c
                ways = 0
                if single_valid:
                    ways += dp[i+1]
                # Check two-digit
                if i+1 < n:
                    # Determine next character
                    if E[i+1] == '?':
                        possible_next = [str(dn) for dn in range(10)]
                    else:
                        possible_next = [E[i+1]]
                    if c == '1':
                        if E[i+1] == '?':
                            ways += dp[i+2] * 10
                        else:
                            ways += dp[i+2]
                    elif c == '2':
                        if E[i+1] == '?':
                            ways += dp[i+2] * 6
                        else:
                            if '0' <= E[i+1] <= '6':
                                ways += dp[i+2]
                    # else no two-digit number
                # If choosing c allows reaching max_decodings
                if ways == dp[i]:
                    result.append(c)
                    i +=1
                    break
                else:
                    # Subtract the number of ways that choosing c would allow
                    # and continue
                    valid = ways
                    if valid < K:
                        K -= valid
                    else:
                        result.append(c)
                        i +=1
                        break
        uncorrupted = ''.join(result)
        print(f"Case #{test_case}: {uncorrupted} {max_decodings}")

if __name__ == "__main__":
    main()
```