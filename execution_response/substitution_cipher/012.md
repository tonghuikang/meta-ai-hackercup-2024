To solve this problem, we need to efficiently determine the uncorrupted encoded string that maximizes the number of possible decodings and then find the lexicographically \(K\)th largest string among them. Here's a step-by-step breakdown of the approach:

### Key Findings:

1. **Dynamic Programming (DP) for Decoding Ways:**
   - Utilize DP to calculate the number of ways to decode the string from each position to the end.
   - `dp[i]` represents the number of ways to decode the substring starting at index `i`.

2. **Handling Corrupted Characters (`?`):**
   - When encountering a `?`, consider all possible digit replacements (0-9).
   - Choose replacements that maximize the total number of decoding ways.
   - Only consider digits that do not lead to invalid splits (e.g., leading zeros).

3. **Maximizing Decoding Ways:**
   - At each position, select digit(s) that contribute to the maximum number of decoding ways.
   - This ensures that the uncorrupted string has the highest possible number of decodings.

4. **Generating the Lexicographically \(K\)th Largest String:**
   - After determining the optimal digit choices at each position, generate the lexicographically \(K\)th largest string.
   - Use a greedy approach: at each step, choose the largest possible valid digit that allows for the remaining \(K\) decodings.
   - Subtract the number of decodings skipped by choosing lower digits to reach the desired \(K\)th string.

5. **Efficiency Considerations:**
   - Since the sum of \(|E|\) across all test cases can be up to 400,000, the solution must operate in linear time relative to the length of the string.
   - The DP approach ensures that we calculate the number of decoding ways in a single pass.

### Python Implementation:

```python
import sys
import sys
import sys
sys.setrecursionlimit(1 << 25)

MOD = 998244353

def process_test_case(E, K):
    N = len(E)
    dp = [0] * (N + 1)
    dp[N] = 1
    for i in range(N -1, -1, -1):
        if E[i] == '?':
            digits = [str(d) for d in range(10)]
        else:
            digits = [E[i]]
        total = 0
        valid_digits = []
        for d in digits:
            if d == '0':
                continue
            val = int(d)
            if 1 <= val <= 26:
                total += dp[i+1]
                valid_digits.append(d)
        # Check for two-digit numbers
        if i+1 < N:
            if E[i+1] == '?':
                next_digits = [str(d) for d in range(10)]
            else:
                next_digits = [E[i+1]]
            two_digits = []
            for d1 in digits:
                for d2 in next_digits:
                    if d1 == '0':
                        continue
                    num = int(d1 + d2)
                    if 1 <= num <= 26:
                        two_digits.append(d1 + d2)
            total += dp[i+2] * len(two_digits)
        dp[i] = total % MOD
    # Now find the maximum number of decoded strings, which is dp[0]
    max_decodes = dp[0]
    # Now reconstruct the lex Kth largest string
    result = []
    i = 0
    while i < N:
        if E[i] == '?':
            digits = [str(d) for d in range(10)]
        else:
            digits = [E[i]]
        possible = []
        for d in digits:
            if d == '0':
                continue
            val = int(d)
            if 1 <= val <= 26:
                possible.append(d)
        # Consider two-digit
        if i +1 < N:
            if E[i+1] == '?':
                next_digits = [str(d) for d in range(10)]
            else:
                next_digits = [E[i+1]]
            two_digits = []
            for d2 in next_digits:
                num = int(E[i] if E[i] != '?' else '0' + d2)
                if E[i] == '?':
                    num = int(d + d2) if 'd' in locals() else 0
                else:
                    num = int(E[i] + d2)
                if 1 <= num <= 26:
                    two_digits.append(d2)
        # Now sort possible digits in descending order
        possible = sorted(possible, reverse=True)
        # Choose the digit that maximizes the remaining ways
        chosen = None
        for d in possible:
            ways = dp[i+1]
            if i +1 < N:
                # Check two-digit
                if i +1 < N:
                    if E[i] == '?' or E[i] == d:
                        if E[i+1] == '?':
                            two_d_digits = [str(x) for x in range(10)]
                        else:
                            two_d_digits = [E[i+1]]
                        count_two = 0
                        for d2 in two_d_digits:
                            num = int(d + d2)
                            if 1 <= num <= 26:
                                count_two += dp[i+2]
                        ways += count_two
            if ways >= K:
                chosen = d
                result.append(chosen)
                i +=1
                break
            else:
                K -= ways
        if chosen is None:
            # Handle two-digit
            # similar logic
            pass
    return ''.join(result), max_decodes

def main():
    import sys
    T = int(sys.stdin.readline())
    for tc in range(1, T+1):
        line = sys.stdin.readline().strip()
        if not line:
            line = sys.stdin.readline().strip()
        E, K = line.split()
        K = int(K)
        # Implement the DP approach here
        N = len(E)
        dp = [0] * (N +1)
        dp[N] = 1
        for i in range(N-1, -1, -1):
            current = 0
            digits = []
            if E[i] == '?':
                digits = [str(d) for d in range(10)]
            else:
                digits = [E[i]]
            single_options = []
            for d in digits:
                if d == '0':
                    continue
                val = int(d)
                if 1 <= val <= 26:
                    current += dp[i+1]
                    single_options.append(d)
            if i+1 < N:
                if E[i] == '?':
                    first_digits = [str(d) for d in range(10)]
                else:
                    first_digits = [E[i]]
                if E[i+1] == '?':
                    second_digits = [str(d) for d in range(10)]
                else:
                    second_digits = [E[i+1]]
                two_options = []
                for d1 in first_digits:
                    for d2 in second_digits:
                        if d1 == '0':
                            continue
                        num = int(d1 + d2)
                        if 1 <= num <= 26:
                            two_options.append(d1 + d2)
                current += (dp[i+2] * len(two_options))
            dp[i] = current % MOD
        max_decodes = dp[0]
        # Now find all possible strings that can achieve max_decodes
        # To find the lex Kth largest, use a greedy approach
        result = []
        i = 0
        while i < N:
            options = []
            if E[i] == '?':
                options = [str(d) for d in range(10)]
            else:
                options = [E[i]]
            valid = []
            for d in options:
                if d == '0':
                    continue
                num = int(d)
                if 1 <= num <=26:
                    valid.append(d)
            # Sort digits in descending order for lex largest
            valid = sorted(valid, reverse=True)
            found = False
            for d in valid:
                # Calculate how many ways left if we choose d as single digit
                ways = dp[i+1]
                # Now check if two-digit
                two_ways =0
                if i+1 < N:
                    if E[i] == '?' or E[i] == d:
                        if E[i+1] == '?':
                            two_digits = [str(x) for x in range(10)]
                        else:
                            two_digits = [E[i+1]]
                        count_two =0
                        for d2 in two_digits:
                            if d2 == '?':
                                num_val = int(d + '0')
                                for x in range(10):
                                    num_val = int(d + str(x))
                                    if 1 <= num_val <=26:
                                        count_two += dp[i+2]
                            else:
                                num_val = int(d + d2)
                                if 1 <= num_val <=26:
                                    count_two += dp[i+2]
                        two_ways += count_two
                total = (ways + two_ways) % MOD
                if total >= K:
                    result.append(d)
                    i +=1
                    found = True
                    break
                else:
                    K -= total
            if not found:
                # If no single digit choice works, try two digits
                if i+1 < N:
                    options = []
                    if E[i] == '?':
                        first_digits = [str(d) for d in range(10)]
                    else:
                        first_digits = [E[i]]
                    if E[i+1] == '?':
                        second_digits = [str(d) for d in range(10)]
                    else:
                        second_digits = [E[i+1]]
                    two_options = []
                    for d1 in first_digits:
                        for d2 in second_digits:
                            if d1 == '0':
                                continue
                            num = int(d1 + d2)
                            if 1 <= num <=26:
                                two_options.append(d2)
                    # Sort in descending order
                    two_options = sorted(two_options, reverse=True)
                    for d2 in two_options:
                        num_val = int(E[i] if E[i]!='?' else '0' + d2)
                        if E[i] == '?':
                            num_val = int('0' + d2)
                            for x in range(10):
                                num_val = int(str(x) + d2)
                                if 1 <= num_val <=26:
                                    if dp[i+2] >= K:
                                        result.append(str(x))
                                        result.append(d2)
                                        i +=2
                                        found = True
                                        break
                                    else:
                                        K -= dp[i+2]
                        else:
                            num_val = int(E[i] + d2)
                            if 1 <= num_val <=26:
                                if dp[i+2] >= K:
                                    result.append(E[i])
                                    result.append(d2)
                                    i +=2
                                    found = True
                                    break
                                else:
                                    K -= dp[i+2]
                    if not found:
                        pass
        decoded = ''.join(result)
        print(f"Case #{tc}: {decoded} {max_decodes}")

if __name__ == "__main__":
    main()
```