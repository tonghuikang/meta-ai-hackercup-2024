**Key Findings:**

To solve the problem, we analyze the expected number of days required to reach the ideal weight \( G \) from the current weight \( W \), given the constraint \( L \). Here's a summary of the approach:

1. **Difference Calculation:** 
   - Let \( d = W - G \), representing the difference between the current weight and the goal.

2. **Expected Days (\( E \)) Calculation:**
   - **Case 1:** If \( L = 0 \), you must decrease your weight by 1 unit each day without any chance of gaining. Therefore, \( E = d \).
   - **Case 2:** If \( L \geq d \), the expectation can be modeled as \( E = d \times (2L + 1) \).
   - **Case 3:** If \( L < d \), the problem involves a more complex scenario where the expectation is given by \( E = \frac{d \times (d + 2L)}{2} \). Since the result can be a fraction, we compute it modulo \( 998244353 \) by multiplying with the modular inverse of 2.

3. **Modular Arithmetic:**
   - To handle fractions under modulo, we use the modular inverse. Specifically, for the case when \( L < d \), we multiply by the inverse of 2 (\( 499122177 \)) to compute \( \frac{1}{2} \) modulo \( 998244353 \).

4. **Implementation Considerations:**
   - Since \( W \), \( G \), and \( L \) can be as large as \( 10^{18} \), the solution must be efficient and based on direct mathematical formulas rather than iterative methods.

Here's the Python code that implements the above logic:

```python
MOD = 998244353

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    T=int(data[0])
    inv2 = pow(2, MOD-2, MOD)
    for tc in range(1, T+1):
        W, G, L = map(int, data[3*(tc-1)+1: 3*tc+1])
        d = W - G
        if L ==0:
            E = d % MOD
        elif L >=d:
            E = (d * (2*L +1)) % MOD
        else:
            p = (d * (d +2*L)) % MOD
            E = (p * inv2) % MOD
        print(f"Case #{tc}: {E}")

if __name__ == "__main__":
    main()
```

```
python
MOD = 998244353

def main():
    import sys
    input = sys.stdin.read
    data = input().split()
    T=int(data[0])
    inv2 = pow(2, MOD-2, MOD)
    for tc in range(1, T+1):
        W, G, L = map(int, data[3*(tc-1)+1: 3*tc+1])
        d = W - G
        if L ==0:
            E = d % MOD
        elif L >=d:
            E = (d * (2*L +1)) % MOD
        else:
            p = (d * (d +2*L)) % MOD
            E = (p * inv2) % MOD
        print(f"Case #{tc}: {E}")

if __name__ == "__main__":
    main()
```