To solve this problem, we need to determine the minimum constant speed \( S \) that Sonic can maintain to deliver sandwiches to all stations within their respective delivery windows \([A_i, B_i]\). Here's the step-by-step reasoning:

1. **Understanding the Constraints:**
   - For each station \( i \), Sonic must reach it within the time interval \([A_i, B_i]\). This translates to:
     \[
     A_i \leq \frac{i}{S} \leq B_i
     \]
     Simplifying, we get:
     \[
     S \geq \frac{i}{B_i} \quad \text{and} \quad S \leq \frac{i}{A_i} \quad \text{(if } A_i > 0\text{)}
     \]
   - Therefore, to find a feasible speed \( S \), we must satisfy these conditions for all stations:
     - **Lower bound:** \( S \) must be at least the maximum of \( \frac{i}{B_i} \) across all stations.
     - **Upper bound:** \( S \) must be at most the minimum of \( \frac{i}{A_i} \) for stations where \( A_i > 0 \).
   
2. **Determining Feasibility:**
   - If the **minimum upper bound** is greater than or equal to the **maximum lower bound**, a feasible speed \( S \) exists, and the minimum such speed is the **maximum lower bound**.
   - If not, it's impossible to deliver to all stations within their delivery windows, and the answer should be `-1`.

3. **Implementation Considerations:**
   - Given the large size of input data, we read the entire input at once and process it efficiently.
   - We compute the lower and upper bounds as described and check the feasibility condition for each test case.
   - The final speed is output with sufficient precision to meet the problem's requirements.

Here is the Python code that implements this logic:

```python
import sys

def main():
    import sys
    import math

    input = sys.stdin.read().split()
    ptr = 0
    T = int(input[ptr]); ptr +=1
    for test_case in range(1, T+1):
        N = int(input[ptr]); ptr +=1
        lower_bound = 0.0
        upper_bound = float('inf')
        for i in range(1, N+1):
            A_i = int(input[ptr]); ptr +=1
            B_i = int(input[ptr]); ptr +=1
            ratio_lower = i / B_i
            lower_bound = max(lower_bound, ratio_lower)
            if A_i >0:
                ratio_upper = i / A_i
                upper_bound = min(upper_bound, ratio_upper)
        if lower_bound <= upper_bound + 1e-12:
            # To ensure precision, format with 10 decimal places and strip trailing zeros
            answer = "{0:.10f}".format(lower_bound).rstrip('0').rstrip('.')
            print(f"Case #{test_case}: {answer}")
        else:
            print(f"Case #{test_case}: -1")

if __name__ == "__main__":
    main()
```