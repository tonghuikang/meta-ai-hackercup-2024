**Key Findings:**

To determine the minimum constant speed \( s \) that Sonic must maintain to deliver sandwiches to all stations within their respective delivery windows, we can analyze the constraints for each station:

1. **Delivery Time Constraint:**
   - For station \( i \), the time taken to reach it is \( t_i = \frac{i}{s} \).
   - To successfully deliver, \( A_i \leq t_i \leq B_i \).
   - This translates to \( \frac{i}{B_i} \leq s \leq \frac{i}{A_i} \) (for \( A_i > 0 \)).

2. **Overall Constraints:**
   - The minimum required speed \( s \) must satisfy \( s \geq \max\left(\frac{i}{B_i}\right) \) across all stations.
   - Additionally, \( s \) must be less than or equal to \( \min\left(\frac{i}{A_i}\right) \) for all stations where \( A_i > 0 \).
   - If \( A_i = 0 \) for any station, there is no upper bound on \( s \) from that station.

3. **Feasibility Check:**
   - If \( \max\left(\frac{i}{B_i}\right) \leq \min\left(\frac{i}{A_i}\right) \), then the minimum feasible speed \( s \) is \( \max\left(\frac{i}{B_i}\right) \).
   - Otherwise, it's impossible to satisfy all delivery windows simultaneously, and the answer is `-1`.

4. **Implementation Considerations:**
   - Due to large input sizes, it's efficient to read all input at once and process it using a pointer to avoid timeouts.
   - Floating-point precision must be handled carefully to ensure accuracy within the specified error bounds.

**Python Code:**

```python
import sys

def main():
    import sys
    import math

    input = sys.stdin.read().split()
    pointer = 0
    T = int(input[pointer]); pointer +=1
    results = []
    for tc in range(1, T+1):
        N = int(input[pointer]); pointer +=1
        max_s_low = 0.0
        min_s_high = float('inf')
        for i in range(1, N+1):
            A_i = int(input[pointer]); pointer +=1
            B_i = int(input[pointer]); pointer +=1
            # Compute s_low = i / B_i
            s_low = i / B_i
            if s_low > max_s_low:
                max_s_low = s_low
            # Compute s_high = i / A_i if A_i >0
            if A_i >0:
                s_high = i / A_i
                if s_high < min_s_high:
                    min_s_high = s_high
        # After all stations
        if max_s_low <= min_s_high:
            # Format the output with up to 10 decimal places to ensure precision
            ans = "{0:.10f}".format(max_s_low).rstrip('0').rstrip('.')
            results.append(f"Case #{tc}: {ans}")
        else:
            results.append(f"Case #{tc}: -1")
    # Print all results
    print('\n'.join(results))

if __name__ == "__main__":
    main()
```