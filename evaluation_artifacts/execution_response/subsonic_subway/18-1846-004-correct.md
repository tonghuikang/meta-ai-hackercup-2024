### Key Findings

To solve the problem of determining the minimum constant speed \( v \) at which Sonic can deliver sandwiches to all stations within their respective delivery windows, we can break down the problem as follows:

1. **Arrival Time Constraint**: 
   - For each station \( i \), located \( i \) miles away, Sonic's arrival time is \( t_i = \frac{i}{v} \) seconds.
   - The delivery window for each station \( i \) is given by the interval \([A_i, B_i]\).
   - Therefore, for successful delivery, it must satisfy \( A_i \leq \frac{i}{v} \leq B_i \).

2. **Speed Constraints**:
   - From \( \frac{i}{v} \leq B_i \), we derive that \( v \geq \frac{i}{B_i} \) for each station \( i \).
   - From \( \frac{i}{v} \geq A_i \), we derive that \( v \leq \frac{i}{A_i} \) for each station \( i \) where \( A_i > 0 \).
   - If \( A_i = 0 \), the upper bound constraint on \( v \) does not apply for that station.

3. **Determining Feasibility**:
   - The minimum feasible speed \( v_{\text{min}} \) is the maximum value of \( \frac{i}{B_i} \) across all stations.
   - The maximum feasible speed \( v_{\text{max}} \) is the minimum value of \( \frac{i}{A_i} \) across all stations with \( A_i > 0 \). If no \( A_i > 0 \), \( v_{\text{max}} \) is considered infinity.
   - A feasible solution exists if and only if \( v_{\text{min}} \leq v_{\text{max}} \). If this condition is met, the minimum speed required is \( v_{\text{min}} \). Otherwise, it's impossible to satisfy all delivery windows, and the output should be `-1`.

4. **Implementation Considerations**:
   - Efficient reading of input is crucial due to the large constraints (up to \( 5{,}000{,}000 \) stations in total).
   - Care must be taken to handle floating-point precision accurately, ensuring the output is within an absolute or relative error of \( 10^{-6} \).
   - Edge cases, such as when all \( A_i = 0 \), or when delivery windows are tight, must be handled correctly.

The following Python code implements the above logic efficiently:

```python
import sys

def main():
    import sys
    import threading

    def solve():
        import sys

        T = int(sys.stdin.readline())
        for test_case in range(1, T+1):
            line = ''
            while line.strip() == '':
                line = sys.stdin.readline()
            N = int(line.strip())
            v_min = 0.0
            v_max = float('inf')
            for i in range(1, N+1):
                while True:
                    line = sys.stdin.readline()
                    if line.strip() != '':
                        break
                A_str, B_str = line.strip().split()
                A_i = float(A_str)
                B_i = float(B_str)
                v_current_min = i / B_i
                if v_current_min > v_min:
                    v_min = v_current_min
                if A_i > 0:
                    v_current_max = i / A_i
                    if v_current_max < v_max:
                        v_max = v_current_max
            if v_min <= v_max:
                # To ensure the output meets the precision requirement
                print(f"Case #{test_case}: {v_min:.10f}".rstrip('0').rstrip('.'))
            else:
                print(f"Case #{test_case}: -1")
    threading.Thread(target=solve).start()

if __name__ == "__main__":
    main()
```