**Key Findings:**

1. **Time Calculation:** For each station \(i\), if Sonic runs at speed \(s\) miles per second, the time to reach station \(i\) is \(t_i = \frac{i}{s}\).

2. **Delivery Window Constraints:** 
   - To deliver on time, Sonic must arrive within the interval \([A_i, B_i]\). 
   - This translates to \(A_i \leq \frac{i}{s} \leq B_i\).

3. **Speed Constraints:**
   - From the above inequality, we derive:
     - \(s \geq \frac{i}{B_i}\) (minimum speed to not be late).
     - \(s \leq \frac{i}{A_i}\) (maximum speed to not arrive too early).
   - For cases where \(A_i = 0\), the upper speed bound is effectively infinity, as there's no restriction on arriving early.

4. **Finding Feasible Speed:**
   - To satisfy all stations, the overall speed \(s\) must satisfy:
     - \(s \geq \max \left(\frac{i}{B_i}\right)\) for all \(i\).
     - \(s \leq \min \left(\frac{i}{A_i}\right)\) for all \(i\) where \(A_i > 0\).
   - If \(\max \left(\frac{i}{B_i}\right) \leq \min \left(\frac{i}{A_i}\right)\), then the minimal feasible speed is \(\max \left(\frac{i}{B_i}\right)\).
   - If no such speed exists (i.e., the maximum lower bound exceeds the minimum upper bound), the answer is \(-1\).

5. **Efficiency Considerations:** 
   - Given the large input size, it's crucial to read and process the input efficiently.
   - Utilizing fast input methods and avoiding unnecessary computations ensures that the solution meets the time constraints.

**Python Code:**

```python
import sys

def main():
    import sys
    import math

    input = sys.stdin.read().split()
    ptr = 0
    T = int(input[ptr]); ptr +=1
    for test_case in range(1, T+1):
        N = int(input[ptr]); ptr +=1
        max_lower = 0.0
        min_upper = float('inf')
        for i in range(1, N+1):
            A = int(input[ptr]); ptr +=1
            B = int(input[ptr]); ptr +=1
            if B ==0:
                # Impossible to deliver
                max_lower = float('inf')
                break
            lower = i / B
            max_lower = max(max_lower, lower)
            if A >0:
                upper = i / A
                min_upper = min(min_upper, upper)
            # If A ==0, no upper bound
        # Continue to read remaining input if broken early
        if max_lower != float('inf'):
            # Check all B_i were read
            pass
        feasible = False
        if max_lower <= min_upper:
            feasible = True
        if feasible:
            # To handle floating point precision as required
            # We'll format with enough decimal places
            print(f"Case #{test_case}: {max_lower:.10f}".rstrip('0').rstrip('.') if '.' in f"{max_lower:.10f}" else f"{max_lower:.10f}")
        else:
            print(f"Case #{test_case}: -1")
        
if __name__ == "__main__":
    main()
```