**Key Findings:**

To determine the minimum constant speed \( s \) that Sonic must maintain to deliver all sandwiches within their respective delivery windows, we analyze each station's constraints:

1. **Arrival Time Calculation:**
   - For station \( i \) located \( i \) miles away, the arrival time \( t_i \) is \( t_i = \frac{i}{s} \).

2. **Delivery Window Constraints:**
   - Sonic must arrive within the interval \([A_i, B_i]\) for each station:
     \[
     A_i \leq \frac{i}{s} \leq B_i
     \]
   - This can be rearranged to derive constraints on \( s \):
     \[
     \frac{i}{B_i} \leq s \leq \frac{i}{A_i} \quad \text{(if } A_i > 0 \text{)}
     \]
   - If \( A_i = 0 \), the upper bound for \( s \) is effectively infinite since there's no lower limit on arrival time.

3. **Aggregating Constraints:**
   - The overall minimum speed \( s \) must satisfy:
     \[
     s \geq \max\left(\frac{i}{B_i}\right) \quad \text{for all } i
     \]
     \[
     s \leq \min\left(\frac{i}{A_i}\right) \quad \text{for all } i \text{ where } A_i > 0
     \]
   - If the maximum lower bound exceeds the minimum upper bound, it's impossible for Sonic to satisfy all delivery windows, and the output should be `-1`.

4. **Implementation Considerations:**
   - Efficient input handling is crucial due to large input sizes.
   - Floating-point precision needs to be managed carefully to ensure accuracy within \( 10^{-6} \).

Based on these findings, the following Python code implements the solution:

```python
import sys
import math

def main():
    import sys

    import sys

    def readints():
        return list(map(int, sys.stdin.read().split()))
    
    data = readints()
    it = iter(data)
    T = next(it)
    for tc in range(1, T+1):
        try:
            N = next(it)
        except StopIteration:
            N = 0
        lower_bound = 0.0
        upper_bound = float('inf')
        for i in range(1, N+1):
            try:
                A_i = next(it)
                B_i = next(it)
            except StopIteration:
                A_i = 0
                B_i = 1
            if B_i ==0:
                # Impossible, since B_i > A_i >=0
                # But according to constraints, B_i > A_i >=0
                # So B_i >=1
                pass
            station_lower = i / B_i
            lower_bound = max(lower_bound, station_lower)
            if A_i >0:
                station_upper = i / A_i
                upper_bound = min(upper_bound, station_upper)
        # Compare lower_bound and upper_bound with allowed precision
        if lower_bound <= upper_bound + 1e-12:
            # Format the lower_bound with up to 10 decimal digits, remove trailing zeros
            s = lower_bound
            s_str = "{0:.10f}".format(s).rstrip('0').rstrip('.')
            print(f"Case #{tc}: {s_str}")
        else:
            print(f"Case #{tc}: -1")

if __name__ == "__main__":
    main()
```