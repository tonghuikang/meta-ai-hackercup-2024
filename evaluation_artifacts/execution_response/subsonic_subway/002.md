**Key Findings:**

To determine the minimum constant speed \( v \) that Sonic needs to maintain to deliver sandwiches to all stations within their respective time windows, we can use the following approach:

1. **Constraints for Each Station:**
   - For each station \( i \), Sonic must arrive within the time window \([A_i, B_i]\).
   - This translates to the inequality \( A_i \leq \frac{i}{v} \leq B_i \).
   - Rearranging, we get \( \frac{i}{B_i} \leq v \leq \frac{i}{A_i} \) (if \( A_i > 0 \)).

2. **Aggregating Constraints:**
   - The **minimum speed** \( v_{\text{min}} \) required is the maximum of all \( \frac{i}{B_i} \) across all stations.
   - The **maximum allowable speed** \( v_{\text{max}} \) is the minimum of all \( \frac{i}{A_i} \) across all stations where \( A_i > 0 \). If \( A_i = 0 \), it imposes no upper bound on \( v \).

3. **Feasibility Check:**
   - If \( v_{\text{min}} \leq v_{\text{max}} \), then the smallest feasible speed is \( v_{\text{min}} \).
   - If not, it's impossible for Sonic to satisfy all delivery windows, and the answer is `-1`.

4. **Efficient Implementation:**
   - Given the large input size constraints, it's optimal to read all input at once and process it efficiently.
   - Floating-point precision is handled to ensure the answer is accurate within the required tolerance.

**Python Code:**

```python
import sys

def solve():
    import sys
    import math
    from sys import stdin
    def input():
        return sys.stdin.read()
    data = input().split()
    idx = 0
    T = int(data[idx]); idx +=1
    for tc in range(1, T+1):
        N = int(data[idx]); idx +=1
        v_min = 0.0
        v_max = float('inf')
        impossible = False
        for i in range(1, N+1):
            A_i = int(data[idx]); idx +=1
            B_i = int(data[idx]); idx +=1
            if B_i ==0:
                # Cannot reach in zero time unless i==0, which isn't possible
                impossible = True
                # Skip remaining inputs
                idx += 2*(N -i)
                break
            v_min_candidate = i / B_i
            if v_min < v_min_candidate:
                v_min = v_min_candidate
            if A_i >0:
                v_max_candidate = i / A_i
                if v_max > v_max_candidate:
                    v_max = v_max_candidate
            # If A_i ==0, no upper bound imposed
        if not impossible and v_min <= v_max + 1e-12:
            # Adding a small epsilon to handle floating point precision
            # Format to at least 6 decimal places
            print(f"Case #{tc}: {v_min:.10f}".rstrip('0').rstrip('.'))
        else:
            print(f"Case #{tc}: -1")
```