To solve this problem, we model the scenario as a constrained random walk with an absorbing barrier at the goal weight \( G \) and a reflecting barrier at \( W + L \). The key observations are:

1. **Random Walk Dynamics**: Each day, the weight can either increase or decrease by 1 unit with equal probability, except when increasing by 1 would violate the constraint \( w > W + L \). In such cases, the weight decreases by 1 unit deterministically.

2. **Expected Steps Calculation**: By analyzing the random walk, we derive that the expected number of days to reach the goal weight \( G \) from the current weight \( W \) is given by:
   \[
   E(W) = (W - G) \times (2L + 1)
   \]
   This formula accounts for the number of steps required to reach \( G \) while considering the constraint imposed by \( L \).

3. **Modulo Operation**: Since the expected number of days can be very large, we compute the result modulo \( 998244353 \) as required.

The Python implementation directly applies this formula for each test case and outputs the result in the specified format.

```python
# Python code to solve the problem

MOD = 998244353

def solve():
    import sys
    T = int(sys.stdin.readline())
    for tc in range(1, T+1):
        W_str, G_str, L_str = sys.stdin.readline().strip().split()
        W = int(W_str)
        G = int(G_str)
        L = int(L_str)
        delta = W - G
        E = delta * (2 * L +1)
        result = E % MOD
        print(f"Case #{tc}: {result}")
```

# Short Answer