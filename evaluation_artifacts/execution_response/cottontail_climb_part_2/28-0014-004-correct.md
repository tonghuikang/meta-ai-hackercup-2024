**Key Findings:**

1. **Mountain Number Characteristics:**
   - **Odd Digit Length:** Mountain numbers have an odd number of digits, specifically \(2k + 1\) for some integer \(k \geq 0\).
   - **Non-Zero Digits:** All digits must be between 1 and 9.
   - **Monotonic Segments:**
     - The first \(k+1\) digits are non-decreasing.
     - The last \(k+1\) digits are non-increasing.
   - **Unique Middle Digit:** The central digit (at position \(k+1\)) must appear only once in the entire number.

2. **Generation Strategy:**
   - **Digit Length Iteration:** Iterate over all possible odd digit lengths up to 19 (since \(10^{18}\) has 19 digits).
   - **Middle Digit Selection:** For each possible middle digit (1 to 9), generate the first \(k\) digits in a non-decreasing manner, ensuring the last digit before the middle is less than the middle digit to maintain uniqueness.
   - **Suffix Generation:** Generate the last \(k\) digits in a non-increasing manner, ensuring they are strictly less than the middle digit to maintain its uniqueness.
   - **Avoid Duplicates:** Ensure that the middle digit does not appear in the suffix.

3. **Efficient Counting:**
   - **Precomputation:** Generate all possible mountain numbers once and sort them. This allows for efficient range queries using binary search.
   - **Divisibility Check:** For each test case, perform binary searches to find mountain numbers within the range \([A, B]\) and count how many are divisible by \(M\).

4. **Edge Cases:**
   - **Single-Digit Numbers:** All single-digit numbers from 1 to 9 are valid mountain numbers.
   - **Zero Handling:** Since mountain numbers cannot contain zero, any range starting from 0 should consider only numbers starting from 1.

5. **Performance Considerations:**
   - Given the constraints (\(T \leq 95\) and mountain numbers up to \(10^{18}\)), precomputing and storing all mountain numbers is feasible.
   - Utilizing efficient algorithms for number generation and range counting (like binary search) ensures that the solution performs well within the given limits.

**Python Code:**

```python
import sys
import bisect
from itertools import combinations_with_replacement, product

def generate_mountain_numbers():
    mountains = set()
    # Single-digit mountain numbers
    for d in range(1, 10):
        mountains.add(d)
    
    # Generate for lengths 3,5,...,19
    for total_digits in range(3, 20, 2):
        k = (total_digits - 1) // 2
        # Middle digit
        for m in range(1, 10):
            # Generate first k digits: non-decreasing, digits from 1 to m-1
            if k == 0:
                first_k_digits_list = ['']
            else:
                # Generate all non-decreasing sequences of length k from 1 to m-1
                # using combinations with replacement
                first_k_digits_list = []
                for comb in combinations_with_replacement(range(1, m), k):
                    first_k_digits_list.append(''.join(map(str, comb)))
                if not first_k_digits_list:
                    continue  # No valid first k digits
            # Generate last k digits: non-increasing, digits from 1 to m-1
            if k == 0:
                last_k_digits_list = ['']
            else:
                # Generate all non-increasing sequences of length k from 1 to m-1
                # This is similar to generating all combinations with replacement
                # in reverse order
                last_k_digits_list = []
                for comb in combinations_with_replacement(range(1, m), k):
                    # To make it non-increasing, sort in reverse
                    sorted_comb = sorted(comb, reverse=True)
                    last_k_digits_list.append(''.join(map(str, sorted_comb)))
                if not last_k_digits_list:
                    continue  # No valid last k digits
            # Combine first k digits, middle digit, and last k digits
            for first in first_k_digits_list:
                for last in last_k_digits_list:
                    num_str = first + str(m) + last
                    # Ensure that the middle digit m does not appear in the last k digits
                    if 'm' in last:
                        continue
                    mountains.add(int(num_str))
    return sorted(mountains)

def main():
    import sys
    import threading
    def run():
        mountains = generate_mountain_numbers()
        T = int(sys.stdin.readline())
        for tc in range(1, T+1):
            A_str, B_str, M_str = sys.stdin.readline().strip().split()
            A = int(A_str)
            B = int(B_str)
            M = int(M_str)
            # Find the indices in mountains where mountain >= A and mountain <= B
            left = bisect.bisect_left(mountains, A)
            right = bisect.bisect_right(mountains, B)
            count = 0
            for num in mountains[left:right]:
                if num % M == 0:
                    count +=1
            print(f"Case #{tc}: {count}")
    threading.Thread(target=run,).start()

if __name__ == "__main__":
    main()
```