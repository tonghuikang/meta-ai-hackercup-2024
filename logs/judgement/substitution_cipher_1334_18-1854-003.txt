After carefully analyzing the three presented solutions, here's a summary of the findings:

### **Solution Analysis**

1. **Solution ID `<index>000</index>`**
   - **Correctness:** The output for the sample input does not match the expected results. For instance:
     - **Sample Case #1:** Expected `122 3` vs. Produced `972 116`.
     - **Sample Case #3:** Expected `135 2` vs. Produced `835 11`.
   - **Conclusion:** **Incorrect**.

2. **Solution ID `<index>002</index>`**
   - **Correctness:** Similarly, the outputs do not align with the expected values.
     - **Sample Case #1:** Expected `122 3` vs. Produced `222 116`.
     - **Sample Case #4:** Expected `110 1` vs. Produced `120 2`.
   - **Conclusion:** **Incorrect**.

3. **Solution ID `<index>001</index>`**
   - **Correctness:** The outputs for the sample input perfectly match the expected results.
     - **Sample Case #1:** `122 3`
     - **Sample Case #2:** `135201 2`
     - **Sample Case #3:** `135 2`
     - **Sample Case #4:** `110 1`
     - **Sample Case #5:** `1122 5`
     - **Sample Case #6:** `322222222121221112223 10946`
   - **Conclusion:** **Correct**.

   Additionally, the algorithm correctly implements dynamic programming to calculate the number of decodings and efficiently constructs the lexicographically \(K\)th largest uncorrupted string.

### **Best Solution Selection**

Based on the correctness of the outputs for the sample inputs and the robustness of the algorithm, **Solution ID `<index>001</index>`** is the best among the presented solutions.

**The best solution is `<index>001</index>`.**