*This problem shares some similarities with part 1, with key differences in bold.*

Your friends, **Dijkstra, Dikjstra, Djikstra, Djkistra, Dkijstra, and Dkjistra**, recently learned about graph theory. They all claim to have invented a new algorithm to find the shortest path between all pairs of nodes in an undirected tree with $N$ nodes (numbered from $1$ to $N$).

Their algorithms all run on a matrix $\text{dist}$. Initially, $\text{dist}[u][v] = \text{dist}[v][u] = 1$ if there exists an edge $u \leftrightarrow v$, $0$ if $u = v$, and $N$ otherwise.

**Dijkstra's** code is as follows:
```
for (int i = 1; i <= N; i++)
  for (int j = 1; j <= N; j++)
    for (int k = 1; k <= N; k++)
      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
```
**Dikjstra's** code is as follows:
```
for (int i = 1; i <= N; i++)
  for (int k = 1; k <= N; k++)
    for (int j = 1; j <= N; j++)
      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
```
**Djikstra's** code is as follows:
```
for (int j = 1; j <= N; j++)
  for (int i = 1; i <= N; i++)
    for (int k = 1; k <= N; k++)
      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
```
**...and so forth, with their names bearing an uncanny resemblance to the order of the loops.**

But do any of them actually work? Thatâ€™s up to you, the coding grandmaster, to find out!  You'll run one of these algorithms on a tree where the $i$-th edge is $U_i \leftrightarrow V_i$. **You're given a 3-letter string $S$, corresponding to letters 2..4 of the name of the person whose code should be run on your tree.**

Output "`Lucky`" if the code correctly populates $\text{dist}[u][v]$ with the shortest path length between all pairs of nodes $u$ and $v$ after it finishes execution, otherwise output "`Wrong`".

# Constraints
$1 \le T \le 115$
$S \in$ {"`ijk`", "`ikj`", "`jik`", "`jki`", "`kij`", "`kji`"}
$2 \le N \le 300{,}000$
$1 \le U_i, V_i \le N $

The provided edges for each case will form a tree.
The sum of $N$ across all test cases is at most $8{,}000{,}000$.

*Note: The full input file for this problem is large (close to 100MB), so we strongly recommend downloading the encrypted zip file.*

# Input Format
Input begins with an integer $T$, the number of test cases. **The first line of each test case contains the string $S$.** The next line contains a single integer $N$.  $N - 1$ lines follow, the $i$-th of which contains two integers $U_i$ and $V_i$.

# Output Format
For each case, print "`Case #i: `" followed by either "`Lucky`" or "`Wrong`" depending on whether the algorithm produces the correct matrix of shortest distances.

# Sample Explanation
The first test case is illustrated below:

{{PHOTO_ID:575364538348496|WIDTH:300}}

In this case, Dikjstra's algorithm produces the following correct distance matrix:
```
0 1 2 2 3
1 0 1 1 2
2 1 0 2 3
2 1 2 0 1
3 2 3 1 0
```
The third test case describes the following tree:

{{PHOTO_ID:1206676467106153|WIDTH:300}}

However, Dikjstra's algorithm will product this incorrect distance matrix:
```
0 3 3 3 1 2
6 0 2 2 2 1
6 2 0 2 2 1
6 2 2 0 2 1
1 2 2 2 0 1
2 1 1 1 1 0
```

The correct matrix is:
```
0 3 3 3 1 2
3 0 2 2 2 1
3 2 0 2 2 1
3 2 2 0 2 1
1 2 2 2 0 1
2 1 1 1 1 0
```