*This problem shares some similarities with part 2, with key differences in bold.*

Your friend, **Dikjstra** (sic), recently learned about graph theory. He claims to have invented a new algorithm to find the shortest path between all pairs of nodes in an undirected tree with $N$ nodes (numbered from $1$ to $N$).

The algorithm runs on a matrix $\text{dist}$. Initially, $\text{dist}[u][v] = \text{dist}[v][u] = 1$ if there exists an edge $u \leftrightarrow v$, $0$ if $u = v$, and $N$ otherwise.

**Dikjstra's** code is as follows:
```
for (int i = 1; i <= N; i++)
  for (int k = 1; k <= N; k++)
    for (int j = 1; j <= N; j++)
      dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
```

But does this actually work? Thatâ€™s up to you, the legendary coding grandmaster, to find out! You'll run this code on a tree where the $i$-th edge is $U_i \leftrightarrow V_i$.

Output "`Lucky`" if the code correctly populates $\text{dist}[u][v]$ with the shortest path length between all pairs of nodes $u$ and $v$ after it finishes execution, otherwise output "`Wrong`".

# Constraints
$1 \le T \le 90$
$2 \le N \le 300{,}000$
$1 \le U_i, V_i \le N $

The provided edges for each case will form a tree.
The sum of $N$ across all test cases is at most $5{,}000{,}000$.

# Input Format
Input begins with an integer $T$, the number of test cases. The first line of each case contains a single integer $N$. $N - 1$ lines follow, the $i$-th of which contains two integers $U_i$ and $V_i$.

# Output Format
For each case, print "`Case #i: `" followed by either "`Lucky`" or "`Wrong`" depending on whether the algorithm produces the correct matrix of shortest distances.

# Sample Explanation
The first test case is illustrated below:

{{PHOTO_ID:511663491865302|WIDTH:300}}

In this case, Dikjstra's algorithm produces the following correct distance matrix:
```
0 1 2 2 3
1 0 1 1 2
2 1 0 2 3
2 1 2 0 1
3 2 3 1 0
```
The third test case describes the following tree:

{{PHOTO_ID:1607939906468100|WIDTH:300}}

However, Dikjstra's algorithm will produce this incorrect distance matrix:
```
0 3 3 3 1 2
6 0 2 2 2 1
6 2 0 2 2 1
6 2 2 0 2 1
1 2 2 2 0 1
2 1 1 1 1 0
```

The correct matrix is:
```
0 3 3 3 1 2
3 0 2 2 2 1
3 2 0 2 2 1
3 2 2 0 2 1
1 2 2 2 0 1
2 1 1 1 1 0
```